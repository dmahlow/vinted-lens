{"version":3,"file":"content.js","mappings":"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","sources":["webpack://vinted-lens/./src/content/index.ts"],"sourcesContent":["import {\n  Message,\n  Selectors,\n  ProductItem,\n  ExtensionState,\n  ProductAnalysis,\n  AnalysisCompletePayload,\n  UpdatePreferencesPayload,\n  UpdateSearchPayload,\n  ShowToastPayload,\n  StartScanPayload,\n  StopScanPayload,\n  ScanProgress,\n  ScanProgressPayload,\n  AnalysisStatusPayload,\n  AnalysisStage\n} from '../types';\n\nclass VintedLensContent {\n  private state: ExtensionState = {\n    isEnabled: true,\n    isScanning: false,\n    preferences: [],\n    currentSearch: null,\n    scanProgress: null\n  };\n\n  private scanQueue: ProductItem[] = [];\n  private activeProducts = new Set<string>();\n  private readonly MAX_CONCURRENT = 8;\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    console.log('🔍 Vinted Lens: Initializing content script');\n\n    // Load initial state from storage\n    const storage = await browser.storage.local.get(['preferences', 'currentSearch']);\n    this.state.preferences = storage.preferences || [];\n    this.state.currentSearch = storage.currentSearch || null;\n    console.log('📋 Loaded preferences:', this.state.preferences);\n    console.log('🔎 Current search:', this.state.currentSearch);\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n    console.log('👂 Message listener set up');\n  }\n\n  private handleMessage(message: Message): void {\n    switch (message.type) {\n      case 'START_SCAN':\n        this.handleStartScan(message.payload as StartScanPayload);\n        break;\n      case 'STOP_SCAN':\n        this.handleStopScan(message.payload as StopScanPayload);\n        break;\n      case 'ANALYSIS_COMPLETE':\n        this.handleAnalysisComplete(message.payload as AnalysisCompletePayload);\n        break;\n      case 'ANALYSIS_STATUS':\n        this.handleAnalysisStatus(message.payload as AnalysisStatusPayload);\n        break;\n      case 'UPDATE_PREFERENCES':\n        this.handlePreferencesUpdate(message.payload as UpdatePreferencesPayload);\n        break;\n      case 'UPDATE_SEARCH':\n        this.handleSearchUpdate(message.payload as UpdateSearchPayload);\n        break;\n      case 'SHOW_TOAST':\n        this.showToast(message.payload as ShowToastPayload);\n        break;\n    }\n  }\n\n  private handleAnalysisStatus(payload: AnalysisStatusPayload): void {\n    const { stage, productId, data } = payload;\n\n    switch (stage) {\n      case 'start':\n        console.log(`🤖 Analyzing product ${productId}:`, {\n          prompt: data?.prompt\n        });\n        break;\n\n      case 'complete':\n        console.log(`✅ Claude response for ${productId}:`, {\n          response: data?.response,\n          timing: data?.timing\n        });\n        break;\n\n      case 'error':\n        console.error(`❌ Analysis failed for ${productId}:`, {\n          error: data?.error\n        });\n        break;\n    }\n  }\n\n  private handleStartScan(payload: StartScanPayload): void {\n    if (this.state.isScanning) {\n      console.log('⏳ Scan already in progress');\n      return;\n    }\n\n    // Update preferences and search term\n    this.state.preferences = payload.preferences;\n    this.state.currentSearch = payload.searchTerm;\n\n    // Get all unanalyzed products\n    this.scanQueue = this.getUnanalyzedProducts();\n\n    if (this.scanQueue.length === 0) {\n      this.showToast({\n        message: 'No items to analyze',\n        type: 'info'\n      });\n      return;\n    }\n\n    // Start scanning\n    this.state.isScanning = true;\n    this.state.scanProgress = {\n      total: this.scanQueue.length,\n      current: 0,\n      currentItem: null,\n      startTime: Date.now()\n    };\n\n    this.updateProgress();\n    this.processNextProduct();\n  }\n\n  private handleStopScan(payload: StopScanPayload): void {\n    if (!this.state.isScanning) return;\n\n    console.log('🛑 Stopping scan:', payload.reason);\n    this.scanQueue = [];\n    this.activeProducts.clear();\n    this.state.isScanning = false;\n    this.state.scanProgress = null;\n\n    this.showToast({\n      message: payload.reason === 'complete'\n        ? 'Scan complete'\n        : 'Scan stopped',\n      type: payload.reason === 'error' ? 'error' : 'info'\n    });\n\n    this.updateProgress();\n  }\n\n  private getUnanalyzedProducts(): ProductItem[] {\n    const items: ProductItem[] = [];\n    const productElements = document.querySelectorAll(\n      `${Selectors.ProductItem}:not(.vinted-lens-analyzed)`\n    );\n\n    productElements.forEach((element, index) => {\n      const imgElement = element.querySelector(Selectors.ProductImage) as HTMLImageElement;\n      const titleElement = element.querySelector(Selectors.ProductTitle);\n      const descElement = element.querySelector(Selectors.ProductDescription);\n\n      if (imgElement && titleElement && descElement) {\n        items.push({\n          id: `item-${Date.now()}-${index}`,\n          element: element as HTMLElement,\n          imageUrl: imgElement.src,\n          title: titleElement.textContent || '',\n          description: descElement.getAttribute('title') || ''\n        });\n      }\n    });\n\n    return items;\n  }\n\n  private async processNextProduct(): Promise<void> {\n    if (!this.state.isScanning) return;\n\n    // Process up to MAX_CONCURRENT products at once\n    while (this.scanQueue.length > 0 && this.activeProducts.size < this.MAX_CONCURRENT) {\n      const product = this.scanQueue.shift()!;\n      console.log('🔄 Processing product:', product.id, {\n        activeProducts: this.activeProducts.size,\n        queueLength: this.scanQueue.length\n      });\n\n      // Update progress\n      if (this.state.scanProgress) {\n        this.state.scanProgress.current++;\n        this.state.scanProgress.currentItem = product.title;\n        this.updateProgress();\n      }\n\n      // Add analyzing class\n      product.element.setAttribute('data-vinted-lens-id', product.id);\n      product.element.classList.add('vinted-lens-analyzing');\n\n      // Track active product\n      this.activeProducts.add(product.id);\n\n      // Start analysis (don't await)\n      this.analyzeProduct(product).catch(error => {\n        console.error('❌ Analysis failed:', error);\n        this.activeProducts.delete(product.id);\n        product.element.classList.remove('vinted-lens-analyzing');\n        // Try next product immediately\n        this.processNextProduct();\n      });\n    }\n\n    // If queue is empty and no active products, we're done\n    if (this.scanQueue.length === 0 && this.activeProducts.size === 0) {\n      this.handleStopScan({ reason: 'complete' });\n    }\n  }\n\n  private async analyzeProduct(product: ProductItem): Promise<void> {\n    console.log('📤 Sending product for analysis:', {\n      id: product.id,\n      imageUrl: product.imageUrl,\n      title: product.title,\n      queueLength: this.scanQueue.length,\n      activeProducts: this.activeProducts.size\n    });\n\n    await browser.runtime.sendMessage({\n      type: 'ANALYZE_PRODUCT',\n      payload: {\n        product: {\n          ...product,\n          element: undefined // Can't send DOM elements\n        },\n        preferences: this.state.preferences,\n        searchTerm: this.state.currentSearch\n      }\n    });\n  }\n\n  private handleAnalysisComplete(payload: AnalysisCompletePayload): void {\n    const { productId, analysis } = payload;\n    console.log('📥 Analysis complete:', {\n      productId,\n      matches: analysis.matches,\n      confidence: analysis.confidence,\n      timing: analysis.timing,\n      queueSize: this.scanQueue.length\n    });\n\n    // Find the product element\n    const productElement = document.querySelector(\n      `${Selectors.ProductItem}[data-vinted-lens-id=\"${productId}\"]`\n    ) as HTMLElement;\n\n    if (!productElement) {\n      console.warn('⚠️ No element found for product:', productId);\n      this.activeProducts.delete(productId);\n      this.processNextProduct();\n      return;\n    }\n\n    // Remove analyzing state\n    productElement.classList.remove('vinted-lens-analyzing');\n    productElement.classList.add('vinted-lens-analyzed');\n\n    // Apply transition class first\n    productElement.classList.add('vinted-lens-transition');\n\n    // Use setTimeout to ensure transition is applied\n    setTimeout(() => {\n      if (analysis.matches) {\n        productElement.classList.add('vinted-lens-match');\n        if (analysis.confidence < 0.8) {\n          productElement.classList.add('vinted-lens-low-confidence');\n        }\n      } else {\n        productElement.classList.add('vinted-lens-hidden');\n      }\n\n      // Remove from active products and process next\n      this.activeProducts.delete(productId);\n      this.processNextProduct();\n    }, 0);\n  }\n\n  private updateProgress(): void {\n    if (!this.state.scanProgress) return;\n\n    // Send progress update\n    browser.runtime.sendMessage({\n      type: 'SCAN_PROGRESS',\n      payload: {\n        progress: this.state.scanProgress\n      } as ScanProgressPayload\n    });\n  }\n\n  private handlePreferencesUpdate(payload: UpdatePreferencesPayload): void {\n    this.state.preferences = payload.preferences;\n    this.resetAnalysis();\n  }\n\n  private handleSearchUpdate(payload: UpdateSearchPayload): void {\n    this.state.currentSearch = payload.search;\n    this.resetAnalysis();\n  }\n\n  private resetAnalysis(): void {\n    // Stop any ongoing scan\n    if (this.state.isScanning) {\n      this.handleStopScan({ reason: 'user' });\n    }\n\n    // Clear analysis classes\n    document.querySelectorAll('.vinted-lens-match, .vinted-lens-hidden, .vinted-lens-low-confidence, .vinted-lens-analyzed')\n      .forEach(element => {\n        element.classList.remove(\n          'vinted-lens-match',\n          'vinted-lens-hidden',\n          'vinted-lens-low-confidence',\n          'vinted-lens-analyzed'\n        );\n        element.removeAttribute('data-vinted-lens-id');\n      });\n  }\n\n  private showToast(options: ShowToastPayload): void {\n    const toast = document.createElement('div');\n    toast.className = `vinted-lens-toast ${options.type || ''}`;\n    toast.textContent = options.message;\n    document.body.appendChild(toast);\n\n    // Force reflow to trigger animation\n    toast.offsetHeight;\n    toast.classList.add('show');\n\n    setTimeout(() => {\n      toast.classList.remove('show');\n      setTimeout(() => toast.remove(), 300);\n    }, options.duration || 3000);\n  }\n}\n\n// Initialize content script\nnew VintedLensContent();\n"],"names":["constructor","state","isEnabled","isScanning","preferences","currentSearch","scanProgress","scanQueue","activeProducts","Set","MAX_CONCURRENT","this","initialize","console","log","storage","browser","local","get","runtime","onMessage","addListener","handleMessage","bind","message","type","handleStartScan","payload","handleStopScan","handleAnalysisComplete","handleAnalysisStatus","handlePreferencesUpdate","handleSearchUpdate","showToast","stage","productId","data","prompt","response","timing","error","searchTerm","getUnanalyzedProducts","length","total","current","currentItem","startTime","Date","now","updateProgress","processNextProduct","reason","clear","items","document","querySelectorAll","forEach","element","index","imgElement","querySelector","titleElement","descElement","push","id","imageUrl","src","title","textContent","description","getAttribute","size","product","shift","queueLength","setAttribute","classList","add","analyzeProduct","catch","delete","remove","sendMessage","undefined","analysis","matches","confidence","queueSize","productElement","warn","setTimeout","progress","resetAnalysis","search","removeAttribute","options","toast","createElement","className","body","appendChild","offsetHeight","duration"],"sourceRoot":""}