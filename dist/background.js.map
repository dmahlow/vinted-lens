{"version":3,"file":"background.js","mappings":"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","sources":["webpack://vinted-lens/./src/background/index.ts","webpack://vinted-lens/./src/utils/index.ts"],"sourcesContent":["import {\n  Message,\n  AnthropicMessage,\n  AnthropicResponse,\n  ProductAnalysis,\n  AnalyzeProductPayload,\n  ProductItem,\n  ShowToastPayload,\n  StorageKeys\n} from '../types';\nimport { imageUrlToBase64 } from '../utils';\n\nclass VintedLensBackground {\n  private apiKey: string | null = null;\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    console.log('üîç Vinted Lens: Initializing background script');\n\n    // Load API key from storage\n    const storage = await browser.storage.local.get(StorageKeys.ApiKey);\n    this.apiKey = storage[StorageKeys.ApiKey] || null;\n\n    // Debug logging\n    console.log('üîë Raw API key from storage:', this.apiKey);\n    console.log('üîë API key details:', {\n      present: !!this.apiKey,\n      value: this.apiKey,\n      keyType: this.apiKey ? typeof this.apiKey : 'null',\n      startsWith: this.apiKey ? this.apiKey.substring(0, 7) : 'n/a',\n      length: this.apiKey ? this.apiKey.length : 0,\n      storage_key_used: StorageKeys.ApiKey\n    });\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n    console.log('üëÇ Message listener set up');\n  }\n\n  private async handleMessage(message: Message): Promise<void> {\n    switch (message.type) {\n      case 'ANALYZE_PRODUCT':\n        await this.handleProductAnalysis(message.payload as AnalyzeProductPayload);\n        break;\n    }\n  }\n\n  private async handleProductAnalysis(payload: AnalyzeProductPayload): Promise<void> {\n    console.log('üì¶ Analyzing product:', payload.product.id);\n\n    if (!this.apiKey) {\n      console.error('‚ùå No API key found');\n      await this.showToast({\n        message: 'Please set your API key in the extension options',\n        type: 'error'\n      });\n      return;\n    }\n\n    try {\n      const startTime = performance.now();\n      const analysis = await this.analyzeProduct(payload);\n      const totalTime = performance.now() - startTime;\n\n      // Send results back to content script\n      await this.sendToActiveTab({\n        type: 'ANALYSIS_COMPLETE',\n        payload: {\n          productId: payload.product.id,\n          analysis: {\n            ...analysis,\n            timing: {\n              ...analysis.timing,\n              total: totalTime\n            }\n          }\n        }\n      });\n\n    } catch (error) {\n      console.error('‚ùå Analysis failed:', error);\n      await this.showToast({\n        message: 'Failed to analyze product',\n        type: 'error'\n      });\n    }\n  }\n\n  private async sendToActiveTab(message: Message): Promise<void> {\n    const tabs = await browser.tabs.query({ active: true, currentWindow: true });\n    if (tabs[0]?.id) {\n      await browser.tabs.sendMessage(tabs[0].id, message);\n    }\n  }\n\n  private async analyzeProduct(payload: AnalyzeProductPayload): Promise<ProductAnalysis> {\n    if (!this.apiKey) {\n      throw new Error('API key is required');\n    }\n\n    const { product, preferences, searchTerm } = payload;\n\n    // Send analysis start status\n    await this.sendToActiveTab({\n      type: 'ANALYSIS_STATUS',\n      payload: {\n        stage: 'start',\n        productId: product.id,\n        data: {\n          prompt: `Analyzing if product matches either:\n${searchTerm ? `- Search term: \"${searchTerm}\"` : ''}\n${preferences.length > 0 ? `- Preferences: ${preferences.join(', ')}` : ''}`\n        }\n      }\n    });\n\n    const startApiCall = performance.now();\n    const messages: AnthropicMessage[] = [\n      {\n        role: 'user',\n        content: [\n          {\n            type: 'text',\n            text: `Analyze if this product matches either:\n${searchTerm ? `- Search term: \"${searchTerm}\"` : ''}\n${preferences.length > 0 ? `- Preferences: ${preferences.join(', ')}` : ''}\n\nProduct details:\nTitle: ${product.title}\nDescription: ${product.description}\n\nRespond in JSON format:\n{\n  \"matches\": boolean,\n  \"confidence\": number between 0 and 1,\n  \"matchedCriteria\": string[], // \"search\" or the specific preference that matched\n  \"description\": string explaining why it matched or didn't match\n}`\n          },\n          {\n            type: 'image',\n            source: {\n              type: 'base64',\n              media_type: 'image/jpeg', // Will be updated with actual type\n              data: '' // Will be filled with base64 data\n            }\n          }\n        ]\n      }\n    ];\n\n    let response;\n    let result: AnthropicResponse;\n\n    try {\n      // Convert image to base64\n      const { data: base64Data, mediaType } = await imageUrlToBase64(product.imageUrl);\n\n      // Update the image source with base64 data\n      messages[0].content[1] = {\n        type: 'image',\n        source: {\n          type: 'base64',\n          media_type: mediaType,\n          data: base64Data\n        }\n      };\n\n      const requestBody = {\n        model: 'claude-3-5-sonnet-20241022',\n        max_tokens: 1024,\n        messages\n      };\n\n      const headers = {\n        'Content-Type': 'application/json',\n        'anthropic-version': '2023-06-01',\n        'x-api-key': this.apiKey,\n        'anthropic-dangerous-direct-browser-access': 'true'\n      };\n\n      // Debug logging\n      console.log('üîÑ Claude API Request:', {\n        url: 'https://api.anthropic.com/v1/messages',\n        method: 'POST',\n        headers,\n        body: JSON.stringify(requestBody, null, 2)\n      });\n\n      response = await fetch('https://api.anthropic.com/v1/messages', {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(requestBody)\n      });\n\n      const responseText = await response.text();\n      console.log('üîÑ Claude API Response:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: Object.fromEntries(response.headers.entries()),\n        body: responseText\n      });\n\n      if (!response.ok) {\n        let errorMessage = `API request failed (${response.status})`;\n\n        if (response.status === 401 || response.status === 403) {\n          errorMessage = 'Invalid API key. Make sure you\\'re using a valid API key from console.anthropic.com';\n        } else if (response.status === 429) {\n          errorMessage = 'Rate limit exceeded. Please try again later.';\n        } else {\n          try {\n            const errorJson = JSON.parse(responseText);\n            errorMessage += `: ${errorJson.error?.message || responseText}`;\n          } catch {\n            errorMessage += `: ${responseText}`;\n          }\n        }\n\n        throw new Error(errorMessage);\n      }\n\n      result = JSON.parse(responseText) as AnthropicResponse;\n      const apiCallTime = performance.now() - startApiCall;\n      const analysisText = result.content[0].text;\n\n      // Send analysis complete status\n      await this.sendToActiveTab({\n        type: 'ANALYSIS_STATUS',\n        payload: {\n          stage: 'complete',\n          productId: product.id,\n          data: {\n            response: analysisText,\n            timing: {\n              apiCall: apiCallTime\n            }\n          }\n        }\n      });\n\n      try {\n        const analysis = JSON.parse(analysisText) as ProductAnalysis;\n        return {\n          ...analysis,\n          timing: {\n            total: apiCallTime,\n            apiCall: apiCallTime\n          }\n        };\n      } catch (error: unknown) {\n        await this.sendToActiveTab({\n          type: 'ANALYSIS_STATUS',\n          payload: {\n            stage: 'error',\n            productId: product.id,\n            data: {\n              error: 'Failed to parse Claude response'\n            }\n          }\n        });\n        throw new Error('Invalid analysis response format');\n      }\n    } catch (error: unknown) {\n      await this.sendToActiveTab({\n        type: 'ANALYSIS_STATUS',\n        payload: {\n          stage: 'error',\n          productId: product.id,\n          data: {\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        }\n      });\n      throw error;\n    }\n  }\n\n  private async showToast(options: ShowToastPayload): Promise<void> {\n    await this.sendToActiveTab({\n      type: 'SHOW_TOAST',\n      payload: options\n    });\n  }\n}\n\n// Initialize background script\nnew VintedLensBackground();\n","import { StorageKeys, UserPreferences } from '../types';\n\n/**\n * Debounce function to limit the rate at which a function can fire\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Get stored preferences from browser storage\n */\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const storage = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey\n  ]);\n\n  return {\n    defaultPreferences: storage[StorageKeys.Preferences] || [],\n    apiKey: storage[StorageKeys.ApiKey] || ''\n  };\n}\n\n/**\n * Format a timestamp in milliseconds to a human-readable duration\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${Math.round(ms)}ms`;\n  }\n\n  const seconds = Math.round(ms / 1000);\n  if (seconds < 60) {\n    return `${seconds}s`;\n  }\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}m ${remainingSeconds}s`;\n}\n\n/**\n * Format a number as a percentage with specified decimal places\n */\nexport function formatPercent(value: number, decimals: number = 1): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Convert an image URL to base64\n */\nexport async function imageUrlToBase64(url: string): Promise<{ data: string; mediaType: string }> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  const mediaType = blob.type || 'image/jpeg'; // Default to JPEG if type is not available\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64data = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/jpeg;base64,\")\n      const base64Clean = base64data.split(',')[1];\n      resolve({ data: base64Clean, mediaType });\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n"],"names":["constructor","apiKey","this","initialize","console","log","storage","browser","local","get","present","value","keyType","startsWith","substring","length","storage_key_used","runtime","onMessage","addListener","handleMessage","bind","message","type","handleProductAnalysis","payload","product","id","error","showToast","startTime","performance","now","analysis","analyzeProduct","totalTime","sendToActiveTab","productId","timing","total","tabs","query","active","currentWindow","sendMessage","Error","preferences","searchTerm","stage","data","prompt","join","startApiCall","messages","role","content","text","title","description","source","media_type","response","result","base64Data","mediaType","async","url","fetch","blob","Promise","resolve","reject","reader","FileReader","onloadend","base64Clean","split","onerror","readAsDataURL","imageUrlToBase64","imageUrl","requestBody","model","max_tokens","headers","method","body","JSON","stringify","responseText","status","statusText","Object","fromEntries","entries","ok","errorMessage","errorJson","parse","apiCallTime","analysisText","apiCall","options"],"sourceRoot":""}