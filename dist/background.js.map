{"version":3,"file":"background.js","mappings":"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","sources":["webpack://vinted-lens/./src/background/index.ts","webpack://vinted-lens/./src/utils/index.ts"],"sourcesContent":["import {\n  Message,\n  GridAnalysis,\n  AnalyzeGridPayload,\n  StorageKeys,\n  ExtensionState,\n  ViewportData\n} from '../types';\nimport { callAnthropic } from '../utils';\n\nclass VintedLensBackground {\n  private state: ExtensionState = {\n    isEnabled: true,\n    isAnalyzing: false,\n    preferences: [],\n    currentSearch: null\n  };\n\n  private lastAnalysisTime: number = 0;\n  private readonly ANALYSIS_COOLDOWN = 2000; // 2 seconds between analyses\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load initial state from storage\n    const storage = await browser.storage.local.get([\n      StorageKeys.Preferences,\n      StorageKeys.CurrentSearch\n    ]);\n\n    this.state.preferences = storage[StorageKeys.Preferences] || [];\n    this.state.currentSearch = storage[StorageKeys.CurrentSearch] || null;\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n\n    // Set up storage change listener\n    browser.storage.onChanged.addListener(this.handleStorageChange.bind(this));\n  }\n\n  private async handleMessage(\n    message: Message,\n    sender: browser.runtime.MessageSender\n  ): Promise<void> {\n    switch (message.type) {\n      case 'ANALYZE_GRID':\n        await this.handleAnalyzeGrid(message.payload as AnalyzeGridPayload, sender.tab?.id);\n        break;\n    }\n  }\n\n  private async handleAnalyzeGrid(payload: AnalyzeGridPayload, tabId?: number): Promise<void> {\n    if (!tabId || this.state.isAnalyzing) return;\n\n    // Check cooldown period\n    const now = Date.now();\n    const timeSinceLastAnalysis = now - this.lastAnalysisTime;\n    if (timeSinceLastAnalysis < this.ANALYSIS_COOLDOWN) {\n      console.log(`Skipping analysis - cooldown period (${Math.round(timeSinceLastAnalysis)}ms elapsed)`);\n      return;\n    }\n\n    this.state.isAnalyzing = true;\n    this.lastAnalysisTime = now;\n\n    try {\n      const { viewport } = payload;\n      const storage = await browser.storage.local.get(StorageKeys.ApiKey);\n      const apiKey = storage[StorageKeys.ApiKey];\n\n      if (!apiKey) {\n        throw new Error('API key not configured');\n      }\n\n      // Call Claude API with viewport screenshot\n      const analysisResult = await callAnthropic(\n        apiKey,\n        [viewport.screenshot],\n        this.state.preferences,\n        this.state.currentSearch\n      );\n\n      // Parse and validate the analysis result\n      let gridItems: any[];\n      try {\n        gridItems = JSON.parse(analysisResult);\n        if (!Array.isArray(gridItems) || !gridItems.every(item =>\n          typeof item.position === 'object' &&\n          typeof item.position.row === 'number' &&\n          typeof item.position.column === 'number' &&\n          typeof item.matches === 'boolean' &&\n          typeof item.confidence === 'number' &&\n          Array.isArray(item.matchedCriteria)\n        )) {\n          throw new Error('Invalid analysis format');\n        }\n      } catch (parseError) {\n        throw new Error('Failed to parse analysis result');\n      }\n\n      // Send results back to content script\n      const analysis: GridAnalysis = {\n        items: gridItems,\n        timestamp: new Date().toISOString()\n      };\n\n      await browser.tabs.sendMessage(tabId, {\n        type: 'ANALYSIS_COMPLETE',\n        payload: { analysis }\n      });\n    } catch (error) {\n      console.error('Analysis failed:', error);\n\n      // Notify content script of failure\n      await browser.tabs.sendMessage(tabId, {\n        type: 'SHOW_TOAST',\n        payload: {\n          message: error instanceof Error ? error.message : 'Analysis failed',\n          type: 'error'\n        }\n      });\n    } finally {\n      this.state.isAnalyzing = false;\n    }\n  }\n\n  private handleStorageChange(\n    changes: { [key: string]: browser.storage.StorageChange },\n    areaName: string\n  ): void {\n    if (areaName !== 'local') return;\n\n    // Update preferences if changed\n    if (changes[StorageKeys.Preferences]) {\n      this.state.preferences = changes[StorageKeys.Preferences].newValue || [];\n    }\n\n    // Update search if changed\n    if (changes[StorageKeys.CurrentSearch]) {\n      this.state.currentSearch = changes[StorageKeys.CurrentSearch].newValue || null;\n    }\n  }\n}\n\n// Initialize background script\nnew VintedLensBackground();\n","import {\n  StorageKeys,\n  UserPreferences,\n  ToastOptions,\n  AnthropicResponse,\n  GridAnalysisResponse\n} from '../types';\n\n// Storage utilities\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const result = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey\n  ]);\n\n  return {\n    defaultPreferences: result[StorageKeys.Preferences] || [],\n    apiKey: result[StorageKeys.ApiKey] || ''\n  };\n}\n\nexport async function savePreferences(preferences: Partial<UserPreferences>): Promise<void> {\n  await browser.storage.local.set({\n    [StorageKeys.Preferences]: preferences.defaultPreferences,\n    [StorageKeys.ApiKey]: preferences.apiKey\n  });\n}\n\n// Image utilities\nexport async function imageToBase64(url: string): Promise<string> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n// UI utilities\nexport function showToast(options: ToastOptions): void {\n  const existingToast = document.querySelector('.vinted-lens-toast');\n  if (existingToast) {\n    existingToast.remove();\n  }\n\n  const toast = document.createElement('div');\n  toast.className = `vinted-lens-toast ${options.type || ''}`;\n  toast.textContent = options.message;\n  document.body.appendChild(toast);\n\n  // Force reflow to trigger animation\n  toast.offsetHeight;\n  toast.classList.add('show');\n\n  setTimeout(() => {\n    toast.classList.remove('show');\n    setTimeout(() => toast.remove(), 300);\n  }, options.duration || 3000);\n}\n\n// Anthropic API utilities\nexport async function callAnthropic(\n  apiKey: string,\n  base64Images: string[],\n  preferences: string[],\n  searchTerms: string | null\n): Promise<string> {\n  const prompt = `Analyze these product images from Vinted.com.\nUser preferences: ${preferences.join(', ')}\n${searchTerms ? `Search terms: ${searchTerms}` : ''}\n\nFor each product, determine if it matches the preferences${searchTerms ? ' and search terms' : ''}.\nRespond with a JSON array where each item has:\n{\n  \"id\": \"item-[index]\",\n  \"matches\": boolean,\n  \"confidence\": number (0-1),\n  \"matchedCriteria\": string[]\n}`;\n\n  const messages = [\n    {\n      role: 'user',\n      content: [\n        { type: 'text', text: prompt },\n        ...base64Images.map(image => ({\n          type: 'image',\n          source: {\n            type: 'base64',\n            media_type: 'image/jpeg',\n            data: image.split(',')[1]\n          }\n        }))\n      ]\n    }\n  ];\n\n  try {\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'anthropic-api-key': apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: 'claude-3-opus-20240229',\n        max_tokens: 1024,\n        messages\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => null);\n      throw new Error(\n        errorData?.error?.message ||\n        `Anthropic API error (${response.status}): ${response.statusText}`\n      );\n    }\n\n    const data = await response.json() as AnthropicResponse;\n\n    if (!data.content || !Array.isArray(data.content)) {\n      throw new Error('Invalid response format from Claude API');\n    }\n\n    // Get the last message content which contains our analysis\n    const lastMessage = data.content[data.content.length - 1];\n\n    if (!lastMessage.text) {\n      throw new Error('No text content in Claude response');\n    }\n\n    // Parse the response as our expected grid analysis format\n    let gridAnalysis: GridAnalysisResponse[];\n    try {\n      gridAnalysis = JSON.parse(lastMessage.text);\n      if (!Array.isArray(gridAnalysis) || !gridAnalysis.every(item =>\n        typeof item.id === 'string' &&\n        typeof item.matches === 'boolean' &&\n        typeof item.confidence === 'number' &&\n        Array.isArray(item.matchedCriteria)\n      )) {\n        throw new Error('Invalid grid analysis format');\n      }\n    } catch (parseError) {\n      throw new Error('Failed to parse Claude response as grid analysis');\n    }\n\n    return JSON.stringify(gridAnalysis);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    throw new Error('Failed to communicate with Claude API');\n  }\n}\n\n// Function utilities\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// DOM utilities\nexport function isElementInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n"],"names":["constructor","state","isEnabled","isAnalyzing","preferences","currentSearch","lastAnalysisTime","ANALYSIS_COOLDOWN","this","initialize","storage","browser","local","get","runtime","onMessage","addListener","handleMessage","bind","onChanged","handleStorageChange","message","sender","type","handleAnalyzeGrid","payload","tab","id","tabId","now","Date","timeSinceLastAnalysis","console","log","Math","round","viewport","apiKey","Error","analysisResult","async","base64Images","searchTerms","messages","role","content","text","join","map","image","source","media_type","data","split","response","fetch","method","headers","body","JSON","stringify","model","max_tokens","ok","errorData","json","catch","error","status","statusText","Array","isArray","lastMessage","length","gridAnalysis","parse","every","item","matches","confidence","matchedCriteria","parseError","callAnthropic","screenshot","gridItems","position","row","column","analysis","items","timestamp","toISOString","tabs","sendMessage","changes","areaName","newValue"],"sourceRoot":""}