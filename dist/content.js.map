{"version":3,"file":"content.js","mappings":"mBAgPA,IAhOA,MAQE,WAAAA,GAPQ,KAAAC,MAAwB,CAC9BC,WAAW,EACXC,aAAa,EACbC,YAAa,GACbC,cAAe,MAIfC,KAAKC,YACP,CAEQ,gBAAMA,GAEZ,MAAMC,QAAgBC,QAAQD,QAAQE,MAAMC,IAAI,CAAC,cAAe,kBAChEL,KAAKL,MAAMG,YAAcI,EAAQJ,aAAe,GAChDE,KAAKL,MAAMI,cAAgBG,EAAQH,eAAiB,KAGpDI,QAAQG,QAAQC,UAAUC,YAAYR,KAAKS,cAAcC,KAAKV,OAG9DA,KAAKW,oBAGLX,KAAKY,qBACP,CAEQ,iBAAAD,GACW,IAAIE,iBCoHlB,SACLC,GAGA,IAAIC,EAEJ,MAAO,IAAIC,KACTC,aAAaF,GACbA,EAAUG,YAAW,IAAMJ,KAAQE,IDvH9B,ICuH0C,CAEnD,CD7HMG,EAAS,KACFnB,KAAKL,MAAME,aACdG,KAAKY,qBACP,KAIKQ,QAAQC,SAASC,KAAM,CAC9BC,WAAW,EACXC,SAAS,GAEb,CAEQ,mBAAAZ,GAEN,IADaS,SAASI,cAAc,cACzB,OAEX,MAAMC,EAAQ1B,KAAK2B,sBACfD,EAAME,QAAU,IAClB5B,KAAK6B,YAAYH,EAErB,CAEQ,mBAAAC,GACN,MAAMD,EAAoB,GACpBI,EAAYT,SAASU,iBAAiB,oBAsB5C,OAnBAD,EAAUE,SAAQ,CAACC,EAAMC,KACvB,GAAIlC,KAAKmC,oBAAoBF,GAAO,CAElC,MAAMG,EAAyB,CAC7BC,IAAKC,KAAKC,MAAML,EANe,GAO/BM,OAAQN,EAPuB,GAW7BE,EAASC,IAXQ,GAWeD,EAASI,OAXZ,GAY/Bd,EAAMe,KAAK,CACTC,GAAI,QAAQR,IACZE,WACAO,QAASV,GAGf,KAGKP,CACT,CAEQ,mBAAAS,CAAoBQ,GAC1B,MAAMC,EAAOD,EAAQE,wBACrB,OACED,EAAKE,KAAO,GACZF,EAAKG,MAAQ,GACbH,EAAKI,SAAWC,OAAOC,aAAe7B,SAAS8B,gBAAgBC,eAC/DR,EAAKS,QAAUJ,OAAOK,YAAcjC,SAAS8B,gBAAgBI,YAEjE,CAEQ,qBAAMC,GACZ,IAEE,MAAMC,QAAsBtD,QAAQuD,QAAQC,aAC5C,IAAKF,EAAcf,GACjB,MAAM,IAAIkB,MAAM,iCASlB,MAAO,CACLC,iBANuB1D,QAAQ2D,KAAKC,kBAAkBN,EAAcf,GAAI,CACxEsB,OAAQ,OACRC,QAAS,KAKTC,SAAU,CACRC,KAAM,EACNC,QAAS,GAGf,CAAE,MAAOC,GAEP,OADAC,QAAQD,MAAM,8BAA+BA,GACtC,IACT,CACF,CAEQ,iBAAMxC,CAAYH,GACxB,IAAI1B,KAAKL,MAAME,YAAf,CAEAG,KAAKL,MAAME,aAAc,EACzB6B,EAAMM,SAAQC,IACZA,EAAKU,QAAQ4B,UAAUC,IAAI,wBAAwB,IAGrD,IAEE,MAAMC,QAAiBzE,KAAKwD,kBAC5B,IAAKiB,EACH,MAAM,IAAIb,MAAM,oCAIZzD,QAAQG,QAAQoE,YAAY,CAChCC,KAAM,eACNC,QAAS,CAAEH,aAEf,CAAE,MAAOJ,GACPC,QAAQD,MAAM,0BAA2BA,GACzCrE,KAAK6E,UAAU,CACbC,QAAS,0BACTH,KAAM,SAEV,C,QACE3E,KAAKL,MAAME,aAAc,EACzB6B,EAAMM,SAAQC,IACZA,EAAKU,QAAQ4B,UAAUQ,OAAO,wBAAwB,GAE1D,CA9BkC,CA+BpC,CAEQ,aAAAtE,CAAcqE,GACpB,OAAQA,EAAQH,MACd,IAAK,oBACH3E,KAAKgF,uBAAuBF,EAAQF,SACpC,MACF,IAAK,qBACH5E,KAAKiF,wBAAwBH,EAAQF,SACrC,MACF,IAAK,gBACH5E,KAAKkF,mBAAmBJ,EAAQF,SAChC,MACF,IAAK,aACH5E,KAAK6E,UAAUC,EAAQF,SAG7B,CAEQ,sBAAAI,CAAuBJ,GAC7B,MAAM,SAAEO,GAAaP,EACf9C,EAAYT,SAASU,iBAAiB,oBAE5CoD,EAASzD,MAAMM,SAASC,IACtB,MAAMC,EAA6B,EAApBD,EAAKG,SAASC,IAAWJ,EAAKG,SAASI,OAChDG,EAAUb,EAAUI,GACrBS,IAEDV,EAAKmD,SACPzC,EAAQ4B,UAAUC,IAAI,qBAClBvC,EAAKoD,WAAa,IACpB1C,EAAQ4B,UAAUC,IAAI,+BAGxB7B,EAAQ4B,UAAUC,IAAI,sBACxB,GAEJ,CAEQ,uBAAAS,CAAwBL,GAC9B5E,KAAKL,MAAMG,YAAc8E,EAAQ9E,YACjCE,KAAKsF,eACP,CAEQ,kBAAAJ,CAAmBN,GACzB5E,KAAKL,MAAMI,cAAgB6E,EAAQW,OACnCvF,KAAKsF,eACP,CAEQ,aAAAA,GACNjE,SAASU,iBAAiB,wEACvBC,SAAQW,IACPA,EAAQ4B,UAAUQ,OAAO,oBAAqB,qBAAsB,6BAA6B,IAErG/E,KAAKY,qBACP,CAEQ,SAAAiE,CAAUW,GAChB,MAAMC,EAAQpE,SAASqE,cAAc,OACrCD,EAAME,UAAY,qBAAqBH,EAAQb,MAAQ,KACvDc,EAAMG,YAAcJ,EAAQV,QAC5BzD,SAASC,KAAKuE,YAAYJ,GAG1BA,EAAMK,aACNL,EAAMlB,UAAUC,IAAI,QAEpBtD,YAAW,KACTuE,EAAMlB,UAAUQ,OAAO,QACvB7D,YAAW,IAAMuE,EAAMV,UAAU,IAAI,GACpCS,EAAQO,UAAY,IACzB,E","sources":["webpack://vinted-lens/./src/content/index.ts","webpack://vinted-lens/./src/utils/index.ts"],"sourcesContent":["import {\n  Message,\n  Selectors,\n  GridItem,\n  ExtensionState,\n  GridAnalysis,\n  GridAnalysisItem,\n  AnalysisCompletePayload,\n  UpdatePreferencesPayload,\n  UpdateSearchPayload,\n  ShowToastPayload,\n  ViewportData,\n  GridPosition\n} from '../types';\nimport { debounce } from '../utils';\n\nclass VintedLensContent {\n  private state: ExtensionState = {\n    isEnabled: true,\n    isAnalyzing: false,\n    preferences: [],\n    currentSearch: null\n  };\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load initial state from storage\n    const storage = await browser.storage.local.get(['preferences', 'currentSearch']);\n    this.state.preferences = storage.preferences || [];\n    this.state.currentSearch = storage.currentSearch || null;\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n\n    // Set up mutation observer for dynamic content\n    this.setupGridObserver();\n\n    // Initial check for product grid\n    this.checkForProductGrid();\n  }\n\n  private setupGridObserver(): void {\n    const observer = new MutationObserver(\n      debounce(() => {\n        if (!this.state.isAnalyzing) {\n          this.checkForProductGrid();\n        }\n      }, 500)\n    );\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  private checkForProductGrid(): void {\n    const grid = document.querySelector(Selectors.ProductGrid);\n    if (!grid) return;\n\n    const items = this.getVisibleGridItems();\n    if (items.length >= 10) { // 5x2 grid\n      this.analyzeGrid(items);\n    }\n  }\n\n  private getVisibleGridItems(): GridItem[] {\n    const items: GridItem[] = [];\n    const gridItems = document.querySelectorAll(Selectors.ProductItem);\n    const gridSize = { rows: 2, columns: 5 }; // Fixed 5x2 grid\n\n    gridItems.forEach((item, index) => {\n      if (this.isElementInViewport(item)) {\n        // Calculate grid position\n        const position: GridPosition = {\n          row: Math.floor(index / gridSize.columns),\n          column: index % gridSize.columns\n        };\n\n        // Only include items that fit in our 5x2 grid\n        if (position.row < gridSize.rows && position.column < gridSize.columns) {\n          items.push({\n            id: `item-${index}`,\n            position,\n            element: item as HTMLElement\n          });\n        }\n      }\n    });\n\n    return items;\n  }\n\n  private isElementInViewport(element: Element): boolean {\n    const rect = element.getBoundingClientRect();\n    return (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n      rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n    );\n  }\n\n  private async captureViewport(): Promise<ViewportData | null> {\n    try {\n      // Get current window ID\n      const currentWindow = await browser.windows.getCurrent();\n      if (!currentWindow.id) {\n        throw new Error('Could not determine window ID');\n      }\n\n      // Capture the visible viewport\n      const screenshot = await browser.tabs.captureVisibleTab(currentWindow.id, {\n        format: 'jpeg',\n        quality: 85\n      });\n\n      return {\n        screenshot,\n        gridSize: {\n          rows: 2,\n          columns: 5\n        }\n      };\n    } catch (error) {\n      console.error('Failed to capture viewport:', error);\n      return null;\n    }\n  }\n\n  private async analyzeGrid(items: GridItem[]): Promise<void> {\n    if (this.state.isAnalyzing) return;\n\n    this.state.isAnalyzing = true;\n    items.forEach(item => {\n      item.element.classList.add('vinted-lens-analyzing');\n    });\n\n    try {\n      // Capture viewport screenshot\n      const viewport = await this.captureViewport();\n      if (!viewport) {\n        throw new Error('Failed to capture viewport');\n      }\n\n      // Send message to background script for analysis\n      await browser.runtime.sendMessage({\n        type: 'ANALYZE_GRID',\n        payload: { viewport }\n      });\n    } catch (error) {\n      console.error('Failed to analyze grid:', error);\n      this.showToast({\n        message: 'Failed to analyze items',\n        type: 'error'\n      });\n    } finally {\n      this.state.isAnalyzing = false;\n      items.forEach(item => {\n        item.element.classList.remove('vinted-lens-analyzing');\n      });\n    }\n  }\n\n  private handleMessage(message: Message): void {\n    switch (message.type) {\n      case 'ANALYSIS_COMPLETE':\n        this.handleAnalysisComplete(message.payload as AnalysisCompletePayload);\n        break;\n      case 'UPDATE_PREFERENCES':\n        this.handlePreferencesUpdate(message.payload as UpdatePreferencesPayload);\n        break;\n      case 'UPDATE_SEARCH':\n        this.handleSearchUpdate(message.payload as UpdateSearchPayload);\n        break;\n      case 'SHOW_TOAST':\n        this.showToast(message.payload as ShowToastPayload);\n        break;\n    }\n  }\n\n  private handleAnalysisComplete(payload: AnalysisCompletePayload): void {\n    const { analysis } = payload;\n    const gridItems = document.querySelectorAll(Selectors.ProductItem);\n\n    analysis.items.forEach((item: GridAnalysisItem) => {\n      const index = (item.position.row * 5) + item.position.column;\n      const element = gridItems[index];\n      if (!element) return;\n\n      if (item.matches) {\n        element.classList.add('vinted-lens-match');\n        if (item.confidence < 0.8) {\n          element.classList.add('vinted-lens-low-confidence');\n        }\n      } else {\n        element.classList.add('vinted-lens-hidden');\n      }\n    });\n  }\n\n  private handlePreferencesUpdate(payload: UpdatePreferencesPayload): void {\n    this.state.preferences = payload.preferences;\n    this.resetAnalysis();\n  }\n\n  private handleSearchUpdate(payload: UpdateSearchPayload): void {\n    this.state.currentSearch = payload.search;\n    this.resetAnalysis();\n  }\n\n  private resetAnalysis(): void {\n    document.querySelectorAll('.vinted-lens-match, .vinted-lens-hidden, .vinted-lens-low-confidence')\n      .forEach(element => {\n        element.classList.remove('vinted-lens-match', 'vinted-lens-hidden', 'vinted-lens-low-confidence');\n      });\n    this.checkForProductGrid();\n  }\n\n  private showToast(options: ShowToastPayload): void {\n    const toast = document.createElement('div');\n    toast.className = `vinted-lens-toast ${options.type || ''}`;\n    toast.textContent = options.message;\n    document.body.appendChild(toast);\n\n    // Force reflow to trigger animation\n    toast.offsetHeight;\n    toast.classList.add('show');\n\n    setTimeout(() => {\n      toast.classList.remove('show');\n      setTimeout(() => toast.remove(), 300);\n    }, options.duration || 3000);\n  }\n}\n\n// Initialize content script\nnew VintedLensContent();\n","import {\n  StorageKeys,\n  UserPreferences,\n  ToastOptions,\n  AnthropicResponse,\n  GridAnalysisResponse\n} from '../types';\n\n// Storage utilities\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const result = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey\n  ]);\n\n  return {\n    defaultPreferences: result[StorageKeys.Preferences] || [],\n    apiKey: result[StorageKeys.ApiKey] || ''\n  };\n}\n\nexport async function savePreferences(preferences: Partial<UserPreferences>): Promise<void> {\n  await browser.storage.local.set({\n    [StorageKeys.Preferences]: preferences.defaultPreferences,\n    [StorageKeys.ApiKey]: preferences.apiKey\n  });\n}\n\n// Image utilities\nexport async function imageToBase64(url: string): Promise<string> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n// UI utilities\nexport function showToast(options: ToastOptions): void {\n  const existingToast = document.querySelector('.vinted-lens-toast');\n  if (existingToast) {\n    existingToast.remove();\n  }\n\n  const toast = document.createElement('div');\n  toast.className = `vinted-lens-toast ${options.type || ''}`;\n  toast.textContent = options.message;\n  document.body.appendChild(toast);\n\n  // Force reflow to trigger animation\n  toast.offsetHeight;\n  toast.classList.add('show');\n\n  setTimeout(() => {\n    toast.classList.remove('show');\n    setTimeout(() => toast.remove(), 300);\n  }, options.duration || 3000);\n}\n\n// Anthropic API utilities\nexport async function callAnthropic(\n  apiKey: string,\n  base64Images: string[],\n  preferences: string[],\n  searchTerms: string | null\n): Promise<string> {\n  const prompt = `Analyze these product images from Vinted.com.\nUser preferences: ${preferences.join(', ')}\n${searchTerms ? `Search terms: ${searchTerms}` : ''}\n\nFor each product, determine if it matches the preferences${searchTerms ? ' and search terms' : ''}.\nRespond with a JSON array where each item has:\n{\n  \"id\": \"item-[index]\",\n  \"matches\": boolean,\n  \"confidence\": number (0-1),\n  \"matchedCriteria\": string[]\n}`;\n\n  const messages = [\n    {\n      role: 'user',\n      content: [\n        { type: 'text', text: prompt },\n        ...base64Images.map(image => ({\n          type: 'image',\n          source: {\n            type: 'base64',\n            media_type: 'image/jpeg',\n            data: image.split(',')[1]\n          }\n        }))\n      ]\n    }\n  ];\n\n  try {\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'anthropic-api-key': apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: 'claude-3-opus-20240229',\n        max_tokens: 1024,\n        messages\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => null);\n      throw new Error(\n        errorData?.error?.message ||\n        `Anthropic API error (${response.status}): ${response.statusText}`\n      );\n    }\n\n    const data = await response.json() as AnthropicResponse;\n\n    if (!data.content || !Array.isArray(data.content)) {\n      throw new Error('Invalid response format from Claude API');\n    }\n\n    // Get the last message content which contains our analysis\n    const lastMessage = data.content[data.content.length - 1];\n\n    if (!lastMessage.text) {\n      throw new Error('No text content in Claude response');\n    }\n\n    // Parse the response as our expected grid analysis format\n    let gridAnalysis: GridAnalysisResponse[];\n    try {\n      gridAnalysis = JSON.parse(lastMessage.text);\n      if (!Array.isArray(gridAnalysis) || !gridAnalysis.every(item =>\n        typeof item.id === 'string' &&\n        typeof item.matches === 'boolean' &&\n        typeof item.confidence === 'number' &&\n        Array.isArray(item.matchedCriteria)\n      )) {\n        throw new Error('Invalid grid analysis format');\n      }\n    } catch (parseError) {\n      throw new Error('Failed to parse Claude response as grid analysis');\n    }\n\n    return JSON.stringify(gridAnalysis);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    throw new Error('Failed to communicate with Claude API');\n  }\n}\n\n// Function utilities\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// DOM utilities\nexport function isElementInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n"],"names":["constructor","state","isEnabled","isAnalyzing","preferences","currentSearch","this","initialize","storage","browser","local","get","runtime","onMessage","addListener","handleMessage","bind","setupGridObserver","checkForProductGrid","MutationObserver","func","timeout","args","clearTimeout","setTimeout","debounce","observe","document","body","childList","subtree","querySelector","items","getVisibleGridItems","length","analyzeGrid","gridItems","querySelectorAll","forEach","item","index","isElementInViewport","position","row","Math","floor","column","push","id","element","rect","getBoundingClientRect","top","left","bottom","window","innerHeight","documentElement","clientHeight","right","innerWidth","clientWidth","captureViewport","currentWindow","windows","getCurrent","Error","screenshot","tabs","captureVisibleTab","format","quality","gridSize","rows","columns","error","console","classList","add","viewport","sendMessage","type","payload","showToast","message","remove","handleAnalysisComplete","handlePreferencesUpdate","handleSearchUpdate","analysis","matches","confidence","resetAnalysis","search","options","toast","createElement","className","textContent","appendChild","offsetHeight","duration"],"sourceRoot":""}