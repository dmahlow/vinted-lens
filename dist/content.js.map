{"version":3,"file":"content.js","mappings":"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","sources":["webpack://vinted-lens/./src/content/index.ts"],"sourcesContent":["import {\n  Message,\n  Selectors,\n  ProductItem,\n  ExtensionState,\n  ProductAnalysis,\n  AnalysisCompletePayload,\n  UpdatePreferencesPayload,\n  UpdateSearchPayload,\n  ShowToastPayload,\n  StartScanPayload,\n  StopScanPayload,\n  ScanProgress,\n  ScanProgressPayload,\n  AnalysisStatusPayload,\n  AnalysisStage,\n  StorageKeys\n} from '../types';\n\nclass VintedLensContent {\n  private state: ExtensionState = {\n    isEnabled: true,\n    isScanning: false,\n    preferences: [],\n    currentSearch: null,\n    scanProgress: null,\n    endlessScroll: false\n  };\n\n  private scanQueue: ProductItem[] = [];\n  private activeProducts = new Set<string>();\n  private readonly MAX_CONCURRENT = 8;\n  private observer: IntersectionObserver | null = null;\n  private mutationObserver: MutationObserver | null = null;\n  private observedProducts = new Set<string>();\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    console.log('üîç Vinted Lens: Initializing content script');\n\n    // Load initial state from storage\n    const storage = await browser.storage.local.get([\n      StorageKeys.Preferences,\n      StorageKeys.CurrentSearch,\n      StorageKeys.EndlessScroll\n    ]);\n    this.state.preferences = storage[StorageKeys.Preferences] || [];\n    this.state.currentSearch = storage[StorageKeys.CurrentSearch] || null;\n    this.state.endlessScroll = storage[StorageKeys.EndlessScroll] || false;\n    console.log('üìã Loaded preferences:', this.state.preferences);\n    console.log('üîé Current search:', this.state.currentSearch);\n    console.log('‚ôæÔ∏è Endless scroll:', this.state.endlessScroll);\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n    console.log('üëÇ Message listener set up');\n\n    // Set up observers if endless scroll is enabled\n    if (this.state.endlessScroll) {\n      console.log('‚ôæÔ∏è Setting up endless scroll mode');\n      this.state.isScanning = true;\n      this.setupIntersectionObserver();\n      this.setupMutationObserver();\n    }\n  }\n\n  private handleMessage(message: Message): void {\n    switch (message.type) {\n      case 'START_SCAN':\n        this.handleStartScan(message.payload as StartScanPayload);\n        break;\n      case 'STOP_SCAN':\n        this.handleStopScan(message.payload as StopScanPayload);\n        break;\n      case 'ANALYSIS_COMPLETE':\n        this.handleAnalysisComplete(message.payload as AnalysisCompletePayload);\n        break;\n      case 'ANALYSIS_STATUS':\n        this.handleAnalysisStatus(message.payload as AnalysisStatusPayload);\n        break;\n      case 'UPDATE_PREFERENCES':\n        this.handlePreferencesUpdate(message.payload as UpdatePreferencesPayload);\n        break;\n      case 'UPDATE_SEARCH':\n        this.handleSearchUpdate(message.payload as UpdateSearchPayload);\n        break;\n      case 'SHOW_TOAST':\n        this.showToast(message.payload as ShowToastPayload);\n        break;\n    }\n  }\n\n  private handleAnalysisStatus(payload: AnalysisStatusPayload): void {\n    const { stage, productId, data } = payload;\n\n    switch (stage) {\n      case 'start':\n        console.log(`ü§ñ Analyzing product ${productId}:`, {\n          prompt: data?.prompt\n        });\n        break;\n\n      case 'complete':\n        console.log(`‚úÖ Claude response for ${productId}:`, {\n          response: data?.response,\n          timing: data?.timing\n        });\n        break;\n\n      case 'error':\n        console.error(`‚ùå Analysis failed for ${productId}:`, {\n          error: data?.error\n        });\n        break;\n    }\n  }\n\n  private setupIntersectionObserver(): void {\n    console.log('üîç Setting up intersection observer');\n    this.observer = new IntersectionObserver(entries => {\n      console.log('üîç Intersection observer triggered:', {\n        entries: entries.length,\n        intersecting: entries.filter(e => e.isIntersecting).length\n      });\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const element = entry.target as HTMLElement;\n          console.log('üîç Element intersecting:', {\n            id: element.id,\n            hasId: !!element.id,\n            classes: element.classList.toString()\n          });\n          if (!this.observedProducts.has(element.id)) {\n            this.queueProductForAnalysis(element);\n          }\n        }\n      });\n    }, {\n      rootMargin: '50px', // Start loading slightly before elements come into view\n      threshold: 0.1 // Trigger when even a small part is visible\n    });\n\n    // Start observing existing products\n    document.querySelectorAll(Selectors.ProductItem).forEach(element => {\n      if (!element.classList.contains('vinted-lens-analyzed')) {\n        this.observer!.observe(element);\n      }\n    });\n  }\n\n  private setupMutationObserver(): void {\n    console.log('üîç Setting up mutation observer');\n    this.mutationObserver = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node instanceof HTMLElement && node.matches(Selectors.ProductItem)) {\n            if (!node.classList.contains('vinted-lens-analyzed')) {\n              this.observer?.observe(node);\n            }\n          }\n        });\n      });\n    });\n\n    const productGrid = document.querySelector(Selectors.ProductGrid);\n    if (productGrid) {\n      this.mutationObserver.observe(productGrid, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  private queueProductForAnalysis(element: HTMLElement): void {\n    console.log('üîÑ Queueing product:', {\n      elementId: element.id,\n      isScanning: this.state.isScanning,\n      queueLength: this.scanQueue.length,\n      activeProducts: this.activeProducts.size\n    });\n\n    const imgElement = element.querySelector(Selectors.ProductImage) as HTMLImageElement;\n    const titleElement = element.querySelector(Selectors.ProductTitle);\n    const descElement = element.querySelector(Selectors.ProductDescription);\n\n    if (!imgElement || !titleElement || !descElement) {\n      console.log('‚ö†Ô∏è Missing required elements:', {\n        hasImage: !!imgElement,\n        hasTitle: !!titleElement,\n        hasDescription: !!descElement\n      });\n      return;\n    }\n\n    if (imgElement && titleElement && descElement) {\n      const product: ProductItem = {\n        id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        element,\n        imageUrl: imgElement.src,\n        title: titleElement.textContent || '',\n        description: descElement.getAttribute('title') || ''\n      };\n\n      element.setAttribute('data-vinted-lens-id', product.id);\n      this.observedProducts.add(product.id);\n      this.scanQueue.push(product);\n\n      // Start processing if we have capacity\n      if (this.activeProducts.size < this.MAX_CONCURRENT) {\n        this.processNextProduct();\n      }\n    }\n  }\n\n  private handleStartScan(payload: StartScanPayload): void {\n    if (this.state.isScanning) {\n      console.log('‚è≥ Scan already in progress');\n      return;\n    }\n\n    // Update preferences and search term\n    this.state.preferences = payload.preferences;\n    this.state.currentSearch = payload.searchTerm;\n\n    // Get all unanalyzed products\n    this.scanQueue = this.getUnanalyzedProducts();\n\n    if (this.scanQueue.length === 0) {\n      this.showToast({\n        message: 'No items to analyze',\n        type: 'info'\n      });\n      return;\n    }\n\n    // Start scanning\n    this.state.isScanning = true;\n    this.state.scanProgress = {\n      total: this.scanQueue.length,\n      current: 0,\n      currentItem: null,\n      startTime: Date.now()\n    };\n\n    this.updateProgress();\n\n    // Set up observers for endless scroll if enabled\n    if (this.state.endlessScroll && !this.observer) {\n      this.setupIntersectionObserver();\n      this.setupMutationObserver();\n    }\n\n    this.processNextProduct();\n  }\n\n  private handleStopScan(payload: StopScanPayload): void {\n    if (!this.state.isScanning) return;\n\n    console.log('üõë Stopping scan:', payload.reason);\n    this.scanQueue = [];\n    this.activeProducts.clear();\n    this.state.isScanning = false;\n    this.state.scanProgress = null;\n\n    // Clean up observers if not in endless scroll mode\n    if (!this.state.endlessScroll) {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      }\n      if (this.mutationObserver) {\n        this.mutationObserver.disconnect();\n        this.mutationObserver = null;\n      }\n      this.observedProducts.clear();\n    }\n\n    this.showToast({\n      message: payload.reason === 'complete'\n        ? 'Scan complete'\n        : 'Scan stopped',\n      type: payload.reason === 'error' ? 'error' : 'info'\n    });\n\n    this.updateProgress();\n  }\n\n  private getUnanalyzedProducts(): ProductItem[] {\n    const items: ProductItem[] = [];\n    const productElements = document.querySelectorAll(\n      `${Selectors.ProductItem}:not(.vinted-lens-analyzed)`\n    );\n\n    productElements.forEach((element, index) => {\n      const imgElement = element.querySelector(Selectors.ProductImage) as HTMLImageElement;\n      const titleElement = element.querySelector(Selectors.ProductTitle);\n      const descElement = element.querySelector(Selectors.ProductDescription);\n\n      if (imgElement && titleElement && descElement) {\n        items.push({\n          id: `item-${Date.now()}-${index}`,\n          element: element as HTMLElement,\n          imageUrl: imgElement.src,\n          title: titleElement.textContent || '',\n          description: descElement.getAttribute('title') || ''\n        });\n      }\n    });\n\n    return items;\n  }\n\n  private async processNextProduct(): Promise<void> {\n    if (!this.state.isScanning) return;\n\n    // Process up to MAX_CONCURRENT products at once\n    while (this.scanQueue.length > 0 && this.activeProducts.size < this.MAX_CONCURRENT) {\n      const product = this.scanQueue.shift()!;\n      console.log('üîÑ Processing product:', product.id, {\n        activeProducts: this.activeProducts.size,\n        queueLength: this.scanQueue.length\n      });\n\n      // Update progress\n      if (this.state.scanProgress) {\n        this.state.scanProgress.current++;\n        this.state.scanProgress.currentItem = product.title;\n        this.updateProgress();\n      }\n\n      // Add analyzing class\n      product.element.setAttribute('data-vinted-lens-id', product.id);\n      product.element.classList.add('vinted-lens-analyzing');\n\n      // Track active product\n      this.activeProducts.add(product.id);\n\n      // Start analysis (don't await)\n      this.analyzeProduct(product).catch(error => {\n        console.error('‚ùå Analysis failed:', error);\n        this.activeProducts.delete(product.id);\n        product.element.classList.remove('vinted-lens-analyzing');\n        // Try next product immediately\n        this.processNextProduct();\n      });\n    }\n\n    // If queue is empty and no active products, we're done\n    if (this.scanQueue.length === 0 && this.activeProducts.size === 0) {\n      this.handleStopScan({ reason: 'complete' });\n    }\n  }\n\n  private async analyzeProduct(product: ProductItem): Promise<void> {\n    console.log('üì§ Sending product for analysis:', {\n      id: product.id,\n      imageUrl: product.imageUrl,\n      title: product.title,\n      queueLength: this.scanQueue.length,\n      activeProducts: this.activeProducts.size\n    });\n\n    await browser.runtime.sendMessage({\n      type: 'ANALYZE_PRODUCT',\n      payload: {\n        product: {\n          ...product,\n          element: undefined // Can't send DOM elements\n        },\n        preferences: this.state.preferences,\n        searchTerm: this.state.currentSearch\n      }\n    });\n  }\n\n  private handleAnalysisComplete(payload: AnalysisCompletePayload): void {\n    const { productId, analysis } = payload;\n    console.log('üì• Analysis complete:', {\n      productId,\n      matches: analysis.matches,\n      confidence: analysis.confidence,\n      timing: analysis.timing,\n      queueSize: this.scanQueue.length\n    });\n\n    // Find the product element\n    const productElement = document.querySelector(\n      `${Selectors.ProductItem}[data-vinted-lens-id=\"${productId}\"]`\n    ) as HTMLElement;\n\n    if (!productElement) {\n      console.warn('‚ö†Ô∏è No element found for product:', productId);\n      this.activeProducts.delete(productId);\n      this.processNextProduct();\n      return;\n    }\n\n    // Remove analyzing state\n    productElement.classList.remove('vinted-lens-analyzing');\n    productElement.classList.add('vinted-lens-analyzed');\n\n    // Apply transition class first\n    productElement.classList.add('vinted-lens-transition');\n\n    // Use setTimeout to ensure transition is applied\n    setTimeout(() => {\n      if (analysis.matches) {\n        productElement.classList.add('vinted-lens-match');\n        if (analysis.confidence < 0.8) {\n          productElement.classList.add('vinted-lens-low-confidence');\n        }\n      } else {\n        productElement.classList.add('vinted-lens-hidden');\n      }\n\n      // Remove from active products and process next\n      this.activeProducts.delete(productId);\n      this.processNextProduct();\n    }, 0);\n  }\n\n  private updateProgress(): void {\n    if (!this.state.scanProgress) return;\n\n    // Send progress update\n    browser.runtime.sendMessage({\n      type: 'SCAN_PROGRESS',\n      payload: {\n        progress: this.state.scanProgress\n      } as ScanProgressPayload\n    });\n  }\n\n  private handlePreferencesUpdate(payload: UpdatePreferencesPayload): void {\n    this.state.preferences = payload.preferences;\n    this.resetAnalysis();\n  }\n\n  private handleSearchUpdate(payload: UpdateSearchPayload): void {\n    this.state.currentSearch = payload.search;\n    this.resetAnalysis();\n  }\n\n  private resetAnalysis(): void {\n    // Stop any ongoing scan\n    if (this.state.isScanning) {\n      this.handleStopScan({ reason: 'user' });\n    }\n\n    // Clear analysis classes\n    document.querySelectorAll('.vinted-lens-match, .vinted-lens-hidden, .vinted-lens-low-confidence, .vinted-lens-analyzed')\n      .forEach(element => {\n        element.classList.remove(\n          'vinted-lens-match',\n          'vinted-lens-hidden',\n          'vinted-lens-low-confidence',\n          'vinted-lens-analyzed'\n        );\n        element.removeAttribute('data-vinted-lens-id');\n      });\n  }\n\n  private showToast(options: ShowToastPayload): void {\n    const toast = document.createElement('div');\n    toast.className = `vinted-lens-toast ${options.type || ''}`;\n    toast.textContent = options.message;\n    document.body.appendChild(toast);\n\n    // Force reflow to trigger animation\n    toast.offsetHeight;\n    toast.classList.add('show');\n\n    setTimeout(() => {\n      toast.classList.remove('show');\n      setTimeout(() => toast.remove(), 300);\n    }, options.duration || 3000);\n  }\n}\n\n// Initialize content script\nnew VintedLensContent();\n"],"names":["constructor","state","isEnabled","isScanning","preferences","currentSearch","scanProgress","endlessScroll","scanQueue","activeProducts","Set","MAX_CONCURRENT","observer","mutationObserver","observedProducts","this","initialize","console","log","storage","browser","local","get","runtime","onMessage","addListener","handleMessage","bind","setupIntersectionObserver","setupMutationObserver","message","type","handleStartScan","payload","handleStopScan","handleAnalysisComplete","handleAnalysisStatus","handlePreferencesUpdate","handleSearchUpdate","showToast","stage","productId","data","prompt","response","timing","error","IntersectionObserver","entries","length","intersecting","filter","e","isIntersecting","forEach","entry","element","target","id","hasId","classes","classList","toString","has","queueProductForAnalysis","rootMargin","threshold","document","querySelectorAll","contains","observe","MutationObserver","mutations","mutation","addedNodes","node","HTMLElement","matches","productGrid","querySelector","childList","subtree","elementId","queueLength","size","imgElement","titleElement","descElement","product","Date","now","Math","random","substr","imageUrl","src","title","textContent","description","getAttribute","setAttribute","add","push","processNextProduct","hasImage","hasTitle","hasDescription","searchTerm","getUnanalyzedProducts","total","current","currentItem","startTime","updateProgress","reason","clear","disconnect","items","index","shift","analyzeProduct","catch","delete","remove","sendMessage","undefined","analysis","confidence","queueSize","productElement","warn","setTimeout","progress","resetAnalysis","search","removeAttribute","options","toast","createElement","className","body","appendChild","offsetHeight","duration"],"sourceRoot":""}