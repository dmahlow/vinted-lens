{"version":3,"file":"background.js","mappings":"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","sources":["webpack://vinted-lens/./src/background/index.ts","webpack://vinted-lens/./src/utils/index.ts"],"sourcesContent":["import {\n  Message,\n  OpenAIMessage,\n  OpenAIResponse,\n  ProductAnalysis,\n  AnalyzeProductPayload,\n  ProductItem,\n  ShowToastPayload,\n  StorageKeys,\n  CostTracking\n} from '../types';\nimport { imageUrlToBase64 } from '../utils';\n\nclass VintedLensBackground {\n  private apiKey: string | null = null;\n  private imageDetail: 'low' | 'high' | 'auto' = 'auto';\n  private costLimit: number = 0;\n  private costTracking: CostTracking = {\n    monthlyTokens: 0,\n    monthlyImages: 0,\n    estimatedCost: 0,\n    lastReset: new Date().toISOString()\n  };\n\n  // Parallel processing\n  private requestQueue: AnalyzeProductPayload[] = [];\n  private activeRequests = new Set<string>();\n  private readonly MAX_CONCURRENT = 8;\n  private queueProcessor: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    console.log('🔍 Vinted Lens: Initializing background script');\n\n    // Load settings from storage\n    const storage = await browser.storage.local.get([\n      StorageKeys.ApiKey,\n      StorageKeys.ImageDetail,\n      StorageKeys.CostLimit,\n      StorageKeys.MonthlyUsage\n    ]);\n\n    // Load and validate API key\n    const rawApiKey = storage[StorageKeys.ApiKey];\n    console.log('🔑 Raw API key from storage:', rawApiKey);\n    console.log('🔑 API key details:', {\n      present: !!rawApiKey,\n      value: rawApiKey,\n      keyType: rawApiKey ? typeof rawApiKey : 'null',\n      startsWith: rawApiKey ? rawApiKey.substring(0, 7) : 'n/a',\n      length: rawApiKey ? rawApiKey.length : 0,\n      storage_key_used: StorageKeys.ApiKey\n    });\n\n    this.apiKey = rawApiKey || null;\n    console.log('🔑 API key after assignment:', {\n      value: this.apiKey,\n      valid: this.isValidApiKey(this.apiKey)\n    });\n    this.imageDetail = storage[StorageKeys.ImageDetail] || 'auto';\n    this.costLimit = storage[StorageKeys.CostLimit] || 0;\n    this.costTracking = storage[StorageKeys.MonthlyUsage] || {\n      monthlyTokens: 0,\n      monthlyImages: 0,\n      estimatedCost: 0,\n      lastReset: new Date().toISOString()\n    };\n\n    // Add storage change listener\n    browser.storage.onChanged.addListener((changes, areaName) => {\n      if (areaName === 'local' && changes[StorageKeys.ApiKey]) {\n        console.log('🔄 API key changed:', {\n          oldValue: changes[StorageKeys.ApiKey].oldValue ? '[REDACTED]' : null,\n          newValue: changes[StorageKeys.ApiKey].newValue ? '[REDACTED]' : null\n        });\n        this.apiKey = changes[StorageKeys.ApiKey].newValue || null;\n        console.log('🔄 API key after change:', {\n          value: this.apiKey,\n          valid: this.isValidApiKey(this.apiKey)\n        });\n      }\n    });\n\n    // Check if we need to reset monthly tracking\n    const lastReset = new Date(this.costTracking.lastReset);\n    const now = new Date();\n    if (lastReset.getMonth() !== now.getMonth() || lastReset.getFullYear() !== now.getFullYear()) {\n      this.costTracking = {\n        monthlyTokens: 0,\n        monthlyImages: 0,\n        estimatedCost: 0,\n        lastReset: now.toISOString()\n      };\n      await this.saveCostTracking();\n    }\n\n    // Debug logging\n    console.log('🔑 Settings loaded:', {\n      apiKeyPresent: !!this.apiKey,\n      apiKeyValid: this.isValidApiKey(this.apiKey),\n      imageDetail: this.imageDetail,\n      costLimit: this.costLimit,\n      costTracking: this.costTracking\n    });\n\n    // Set up message listeners\n    browser.runtime.onMessage.addListener(this.handleMessage.bind(this));\n    console.log('👂 Message listener set up');\n  }\n\n  private async saveCostTracking(): Promise<void> {\n    await browser.storage.local.set({\n      [StorageKeys.MonthlyUsage]: this.costTracking\n    });\n  }\n\n  private getImageTokens(detail: 'low' | 'high' | 'auto'): number {\n    switch (detail) {\n      case 'low':\n        return 85;\n      case 'high':\n        return 765; // Conservative estimate, could be up to 1105\n      case 'auto':\n        return 765; // Use high estimate for auto mode\n    }\n  }\n\n  private async updateCostTracking(apiResponse: OpenAIResponse): Promise<void> {\n    // Get image tokens\n    const imageTokens = this.getImageTokens(this.imageDetail);\n\n    // Get prompt and completion tokens from API response\n    const inputTokens = apiResponse.usage.prompt_tokens + imageTokens;\n    const outputTokens = apiResponse.usage.completion_tokens;\n\n    // Update tracking\n    this.costTracking.monthlyTokens += (inputTokens + outputTokens);\n    this.costTracking.monthlyImages += 1;\n\n    // Calculate cost (GPT-4o-mini pricing)\n    // Input: $0.15 per 1M tokens = $0.00015 per 1K tokens\n    // Output: $0.60 per 1M tokens = $0.0006 per 1K tokens\n    const costPerInputToken = 0.00015; // $0.15 per 1M tokens\n    const costPerOutputToken = 0.0006; // $0.60 per 1M tokens\n\n    this.costTracking.estimatedCost = (\n      (inputTokens * costPerInputToken) +\n      (outputTokens * costPerOutputToken)\n    );\n\n    console.log('💰 Cost tracking updated:', {\n      imageTokens,\n      promptTokens: apiResponse.usage.prompt_tokens,\n      completionTokens: apiResponse.usage.completion_tokens,\n      totalTokens: inputTokens + outputTokens,\n      estimatedCost: this.costTracking.estimatedCost\n    });\n\n    await this.saveCostTracking();\n\n    // Check if we've exceeded the cost limit\n    if (this.costLimit > 0 && this.costTracking.estimatedCost > this.costLimit) {\n      throw new Error('Monthly cost limit exceeded');\n    }\n  }\n\n  private async handleMessage(message: Message): Promise<void> {\n    switch (message.type) {\n      case 'ANALYZE_PRODUCT':\n        this.handleProductAnalysis(message.payload as AnalyzeProductPayload);\n        break;\n    }\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.requestQueue.length === 0 || this.activeRequests.size >= this.MAX_CONCURRENT) {\n      console.log('⏸️ Queue processing paused:', {\n        queueLength: this.requestQueue.length,\n        activeRequests: this.activeRequests.size,\n        maxConcurrent: this.MAX_CONCURRENT\n      });\n      return;\n    }\n\n    const payload = this.requestQueue.shift()!;\n    this.activeRequests.add(payload.product.id);\n    console.log('🔄 Processing from queue:', {\n      productId: payload.product.id,\n      queueLength: this.requestQueue.length,\n      activeRequests: this.activeRequests.size,\n      maxConcurrent: this.MAX_CONCURRENT\n    });\n\n    try {\n      const startTime = performance.now();\n      const analysis = await this.analyzeProduct(payload);\n      const totalTime = performance.now() - startTime;\n\n      // Send results back to content script\n      await this.sendToActiveTab({\n        type: 'ANALYSIS_COMPLETE',\n        payload: {\n          productId: payload.product.id,\n          analysis: {\n            ...analysis,\n            timing: {\n              ...analysis.timing,\n              total: totalTime\n            }\n          }\n        }\n      });\n    } catch (error) {\n      console.error('❌ Analysis failed:', error);\n      await this.showToast({\n        message: 'Failed to analyze product',\n        type: 'error'\n      });\n    } finally {\n      this.activeRequests.delete(payload.product.id);\n\n      // Process next item immediately\n      this.processQueue();\n    }\n\n    // Process next item if we have capacity\n    if (this.activeRequests.size < this.MAX_CONCURRENT) {\n      this.processQueue();\n    }\n  }\n\n  private isValidApiKey(key: string | null): boolean {\n    return !!key && (key.startsWith('sk-') || key.startsWith('sk-proj-'));\n  }\n\n  private handleProductAnalysis(payload: AnalyzeProductPayload): void {\n    console.log('📦 Queueing product:', payload.product.id);\n\n    if (!this.isValidApiKey(this.apiKey)) {\n      console.error('❌ No valid API key found');\n      this.showToast({\n        message: 'Please set your API key in the extension options',\n        type: 'error'\n      });\n      return;\n    }\n\n    // Add to queue\n    this.requestQueue.push(payload);\n    console.log('📥 Added to queue:', {\n      productId: payload.product.id,\n      queueLength: this.requestQueue.length,\n      activeRequests: this.activeRequests.size,\n      maxConcurrent: this.MAX_CONCURRENT\n    });\n\n    // Start processing if we have capacity\n    if (this.activeRequests.size < this.MAX_CONCURRENT) {\n      console.log('▶️ Starting queue processing');\n      this.processQueue();\n    }\n  }\n\n  private async sendToActiveTab(message: Message): Promise<void> {\n    const tabs = await browser.tabs.query({ active: true, currentWindow: true });\n    if (tabs[0]?.id) {\n      await browser.tabs.sendMessage(tabs[0].id, message);\n    }\n  }\n\n  private extractJsonFromResponse(text: string): string {\n    // Remove markdown code block if present\n    const jsonMatch = text.match(/```(?:json)?\\n?(.*?)```/s);\n    return jsonMatch ? jsonMatch[1].trim() : text.trim();\n  }\n\n  private async analyzeProduct(payload: AnalyzeProductPayload): Promise<ProductAnalysis> {\n    if (!this.apiKey) {\n      throw new Error('API key is required');\n    }\n\n    const { product, preferences, searchTerm } = payload;\n\n    // Send analysis start status\n    await this.sendToActiveTab({\n      type: 'ANALYSIS_STATUS',\n      payload: {\n        stage: 'start',\n        productId: product.id,\n        data: {\n          prompt: `Analyzing if product matches either:\n${searchTerm ? `- Search term: \"${searchTerm}\"` : ''}\n${preferences.length > 0 ? `- Preferences: ${preferences.join(', ')}` : ''}`\n        }\n      }\n    });\n\n    const startApiCall = performance.now();\n      const messages: OpenAIMessage[] = [\n        {\n          role: 'user',\n          content: [\n            {\n              type: 'text',\n              text: `Analyze if this product matches either:\n${searchTerm ? `- Search term: \"${searchTerm}\"` : ''}\n${preferences.length > 0 ? `- Preferences: ${preferences.join(', ')}` : ''}\n\nProduct details:\nTitle: ${product.title}\nDescription: ${product.description}\n\nRespond in JSON format:\n{\n  \"matches\": boolean,\n  \"confidence\": number between 0 and 1,\n  \"matchedCriteria\": string[], // \"search\" or the specific preference that matched\n  \"description\": string explaining why it matched or didn't match\n}`\n            }\n          ]\n        }\n      ];\n\n      let response;\n      let result: OpenAIResponse;\n\n      try {\n        // Convert image to base64\n        const { data: base64Data, mediaType } = await imageUrlToBase64(product.imageUrl);\n\n        // Add image to message content\n        messages[0].content.push({\n          type: 'image_url',\n          image_url: {\n            url: `data:${mediaType};base64,${base64Data}`,\n            detail: this.imageDetail\n          }\n        });\n\n        const requestBody = {\n          model: 'gpt-4o-mini',\n          messages,\n          max_tokens: 300\n        };\n\n        const headers = {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.apiKey}`\n        };\n\n        // Debug logging\n        console.log('🔄 OpenAI API Request:', {\n          url: 'https://api.openai.com/v1/chat/completions',\n          method: 'POST',\n          headers: { ...headers, Authorization: 'Bearer [REDACTED]' },\n          body: JSON.stringify(requestBody, null, 2)\n        });\n\n        response = await fetch('https://api.openai.com/v1/chat/completions', {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(requestBody)\n        });\n\n        const responseText = await response.text();\n        console.log('🔄 OpenAI API Response:', {\n          status: response.status,\n          statusText: response.statusText,\n          headers: Object.fromEntries(response.headers.entries()),\n          body: responseText\n        });\n\n        if (!response.ok) {\n          let errorMessage = `API request failed (${response.status})`;\n\n          if (response.status === 401) {\n            errorMessage = 'Invalid API key. Make sure you\\'re using a valid API key from platform.openai.com';\n          } else if (response.status === 429) {\n            errorMessage = 'Rate limit exceeded. Please try again later.';\n          } else if (response.status === 400) {\n            errorMessage = 'Invalid request format';\n          } else {\n            try {\n              const errorJson = JSON.parse(responseText);\n              errorMessage += `: ${errorJson.error?.message || responseText}`;\n            } catch {\n              errorMessage += `: ${responseText}`;\n            }\n          }\n\n          throw new Error(errorMessage);\n        }\n\n        result = JSON.parse(responseText) as OpenAIResponse;\n        const apiCallTime = performance.now() - startApiCall;\n\n        // Calculate and track token usage\n        await this.updateCostTracking(result);\n\n        const analysisText = result.choices[0].message.content;\n\n        // Send analysis complete status\n        await this.sendToActiveTab({\n          type: 'ANALYSIS_STATUS',\n          payload: {\n            stage: 'complete',\n            productId: product.id,\n            data: {\n              response: analysisText,\n              timing: {\n                apiCall: apiCallTime\n              }\n            }\n          }\n        });\n\n        try {\n          // Extract JSON from potential code block and parse\n          const cleanJson = this.extractJsonFromResponse(analysisText);\n          console.log('🔄 Extracted JSON:', {\n            original: analysisText,\n            cleaned: cleanJson\n          });\n          const analysis = JSON.parse(cleanJson) as ProductAnalysis;\n          return {\n            ...analysis,\n            timing: {\n              total: apiCallTime,\n              apiCall: apiCallTime\n            }\n          };\n        } catch (error: unknown) {\n          await this.sendToActiveTab({\n            type: 'ANALYSIS_STATUS',\n            payload: {\n              stage: 'error',\n              productId: product.id,\n              data: {\n                error: 'Failed to parse OpenAI response'\n              }\n            }\n          });\n          throw new Error('Invalid analysis response format');\n        }\n    } catch (error: unknown) {\n      await this.sendToActiveTab({\n        type: 'ANALYSIS_STATUS',\n        payload: {\n          stage: 'error',\n          productId: product.id,\n          data: {\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }\n        }\n      });\n      throw error;\n    }\n  }\n\n  private async showToast(options: ShowToastPayload): Promise<void> {\n    await this.sendToActiveTab({\n      type: 'SHOW_TOAST',\n      payload: options\n    });\n  }\n}\n\n// Initialize background script\nnew VintedLensBackground();\n","import { StorageKeys, UserPreferences } from '../types';\n\n/**\n * Debounce function to limit the rate at which a function can fire\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Get stored preferences from browser storage\n */\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const storage = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey,\n    StorageKeys.ImageDetail,\n    StorageKeys.CostLimit,\n    StorageKeys.EndlessScroll\n  ]);\n\n  return {\n    defaultPreferences: storage[StorageKeys.Preferences] || [],\n    apiKey: storage[StorageKeys.ApiKey] || '',\n    imageDetail: storage[StorageKeys.ImageDetail] || 'auto',\n    costLimit: storage[StorageKeys.CostLimit] || 0,\n    endlessScroll: storage[StorageKeys.EndlessScroll] || false\n  };\n}\n\n/**\n * Format a timestamp in milliseconds to a human-readable duration\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${Math.round(ms)}ms`;\n  }\n\n  const seconds = Math.round(ms / 1000);\n  if (seconds < 60) {\n    return `${seconds}s`;\n  }\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}m ${remainingSeconds}s`;\n}\n\n/**\n * Format a number as a percentage with specified decimal places\n */\nexport function formatPercent(value: number, decimals: number = 1): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Convert an image URL to base64\n */\nexport async function imageUrlToBase64(url: string): Promise<{ data: string; mediaType: string }> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  const mediaType = blob.type || 'image/jpeg'; // Default to JPEG if type is not available\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64data = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/jpeg;base64,\")\n      const base64Clean = base64data.split(',')[1];\n      resolve({ data: base64Clean, mediaType });\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n"],"names":["constructor","apiKey","imageDetail","costLimit","costTracking","monthlyTokens","monthlyImages","estimatedCost","lastReset","Date","toISOString","requestQueue","activeRequests","Set","MAX_CONCURRENT","queueProcessor","this","initialize","console","log","storage","browser","local","get","rawApiKey","present","value","keyType","startsWith","substring","length","storage_key_used","valid","isValidApiKey","onChanged","addListener","changes","areaName","oldValue","newValue","now","getMonth","getFullYear","saveCostTracking","apiKeyPresent","apiKeyValid","runtime","onMessage","handleMessage","bind","set","getImageTokens","detail","updateCostTracking","apiResponse","imageTokens","inputTokens","usage","prompt_tokens","outputTokens","completion_tokens","promptTokens","completionTokens","totalTokens","Error","message","type","handleProductAnalysis","payload","processQueue","size","queueLength","maxConcurrent","shift","add","product","id","productId","startTime","performance","analysis","analyzeProduct","totalTime","sendToActiveTab","timing","total","error","showToast","delete","key","push","tabs","query","active","currentWindow","sendMessage","extractJsonFromResponse","text","jsonMatch","match","trim","preferences","searchTerm","stage","data","prompt","join","startApiCall","messages","role","content","title","description","response","result","base64Data","mediaType","async","url","fetch","blob","Promise","resolve","reject","reader","FileReader","onloadend","base64Clean","split","onerror","readAsDataURL","imageUrlToBase64","imageUrl","image_url","requestBody","model","max_tokens","headers","method","Authorization","body","JSON","stringify","responseText","status","statusText","Object","fromEntries","entries","ok","errorMessage","errorJson","parse","apiCallTime","analysisText","choices","apiCall","cleanJson","original","cleaned","options"],"sourceRoot":""}