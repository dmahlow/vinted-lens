{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://vinted-lens/./src/utils/index.ts","webpack://vinted-lens/./src/popup/index.ts"],"sourcesContent":["import { StorageKeys, UserPreferences } from '../types';\n\n/**\n * Debounce function to limit the rate at which a function can fire\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Get stored preferences from browser storage\n */\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const storage = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey,\n    StorageKeys.ImageDetail,\n    StorageKeys.CostLimit\n  ]);\n\n  return {\n    defaultPreferences: storage[StorageKeys.Preferences] || [],\n    apiKey: storage[StorageKeys.ApiKey] || '',\n    imageDetail: storage[StorageKeys.ImageDetail] || 'auto',\n    costLimit: storage[StorageKeys.CostLimit] || 0\n  };\n}\n\n/**\n * Format a timestamp in milliseconds to a human-readable duration\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${Math.round(ms)}ms`;\n  }\n\n  const seconds = Math.round(ms / 1000);\n  if (seconds < 60) {\n    return `${seconds}s`;\n  }\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}m ${remainingSeconds}s`;\n}\n\n/**\n * Format a number as a percentage with specified decimal places\n */\nexport function formatPercent(value: number, decimals: number = 1): string {\n  return `${(value * 100).toFixed(decimals)}%`;\n}\n\n/**\n * Convert an image URL to base64\n */\nexport async function imageUrlToBase64(url: string): Promise<{ data: string; mediaType: string }> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  const mediaType = blob.type || 'image/jpeg'; // Default to JPEG if type is not available\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64data = reader.result as string;\n      // Remove the data URL prefix (e.g., \"data:image/jpeg;base64,\")\n      const base64Clean = base64data.split(',')[1];\n      resolve({ data: base64Clean, mediaType });\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n","import {\n  Message,\n  StorageKeys,\n  UpdatePreferencesPayload,\n  UpdateSearchPayload,\n  StartScanPayload,\n  StopScanPayload,\n  ScanProgressPayload,\n  ScanProgress\n} from '../types';\nimport { debounce } from '../utils';\n\nclass VintedLensPopup {\n  private preferencesInput: HTMLInputElement;\n  private searchInput: HTMLInputElement;\n  private scanButton: HTMLButtonElement;\n  private stopButton: HTMLButtonElement;\n  private settingsButton: HTMLButtonElement;\n  private statusElement: HTMLElement;\n  private progressSection: HTMLElement;\n  private progressBar: HTMLElement;\n  private progressCount: HTMLElement;\n  private progressPercent: HTMLElement;\n  private currentItem: HTMLElement;\n\n  constructor() {\n    this.preferencesInput = document.getElementById('preferences') as HTMLInputElement;\n    this.searchInput = document.getElementById('search') as HTMLInputElement;\n    this.scanButton = document.getElementById('scan') as HTMLButtonElement;\n    this.stopButton = document.getElementById('stop') as HTMLButtonElement;\n    this.settingsButton = document.getElementById('settings') as HTMLButtonElement;\n    this.statusElement = document.getElementById('status') as HTMLElement;\n    this.progressSection = document.querySelector('.progress-section') as HTMLElement;\n    this.progressBar = document.querySelector('.progress-bar-fill') as HTMLElement;\n    this.progressCount = document.querySelector('.progress-count') as HTMLElement;\n    this.progressPercent = document.querySelector('.progress-percent') as HTMLElement;\n    this.currentItem = document.querySelector('.current-item') as HTMLElement;\n\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load stored values\n    const storage = await browser.storage.local.get([\n      StorageKeys.Preferences,\n      StorageKeys.CurrentSearch\n    ]);\n\n    // Set initial values\n    this.preferencesInput.value = (storage[StorageKeys.Preferences] || []).join(', ');\n    this.searchInput.value = storage[StorageKeys.CurrentSearch] || '';\n\n    // Setup event listeners\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    // Handle preference changes\n    this.preferencesInput.addEventListener('input', debounce(() => {\n      this.updatePreferences();\n    }, 500));\n\n    // Handle search changes\n    this.searchInput.addEventListener('input', debounce(() => {\n      this.updateSearch();\n    }, 500));\n\n    // Handle scan button click\n    this.scanButton.addEventListener('click', async () => {\n      // Disable scan button while scanning\n      this.scanButton.disabled = true;\n      this.scanButton.style.display = 'none';\n      this.stopButton.style.display = 'block';\n\n      // Show progress section\n      this.progressSection.classList.add('active');\n\n      await this.startScan();\n    });\n\n    // Handle stop button click\n    this.stopButton.addEventListener('click', () => {\n      this.stopScan('user');\n\n      // Re-enable scan button\n      this.scanButton.disabled = false;\n      this.scanButton.style.display = 'block';\n      this.stopButton.style.display = 'none';\n\n      // Hide progress section\n      this.progressSection.classList.remove('active');\n    });\n\n    // Handle settings button click\n    this.settingsButton.addEventListener('click', () => {\n      browser.runtime.openOptionsPage();\n    });\n\n    // Listen for progress updates\n    browser.runtime.onMessage.addListener((message: Message) => {\n      if (message.type === 'SCAN_PROGRESS') {\n        this.handleProgress(message.payload as ScanProgressPayload);\n      }\n    });\n  }\n\n  private handleProgress(payload: ScanProgressPayload): void {\n    const { progress } = payload;\n    const percent = Math.round((progress.current / progress.total) * 100);\n\n    // Update progress bar\n    this.progressBar.style.width = `${percent}%`;\n\n    // Update text\n    this.progressCount.textContent = `${progress.current}/${progress.total} items`;\n    this.progressPercent.textContent = `${percent}%`;\n\n    // Update current item\n    this.currentItem.textContent = progress.currentItem ?\n      `Analyzing: ${progress.currentItem}` :\n      'Scanning items...';\n\n    // If scan is complete, reset UI\n    if (progress.current === progress.total) {\n      setTimeout(() => {\n        this.scanButton.disabled = false;\n        this.scanButton.style.display = 'block';\n        this.stopButton.style.display = 'none';\n        this.progressSection.classList.remove('active');\n        this.updateStatus('Scan complete');\n      }, 1000);\n    }\n  }\n\n  private async updatePreferences(): Promise<void> {\n    const preferences = this.preferencesInput.value\n      .split(',')\n      .map(pref => pref.trim())\n      .filter(pref => pref.length > 0);\n\n    await browser.storage.local.set({\n      [StorageKeys.Preferences]: preferences\n    });\n\n    this.updateStatus('Preferences updated');\n\n    // Notify content script\n    await this.broadcastMessage({\n      type: 'UPDATE_PREFERENCES',\n      payload: { preferences } as UpdatePreferencesPayload\n    });\n  }\n\n  private async updateSearch(): Promise<void> {\n    const search = this.searchInput.value.trim();\n\n    await browser.storage.local.set({\n      [StorageKeys.CurrentSearch]: search\n    });\n\n    this.updateStatus('Search updated');\n\n    // Notify content script\n    await this.broadcastMessage({\n      type: 'UPDATE_SEARCH',\n      payload: { search } as UpdateSearchPayload\n    });\n  }\n\n  private async startScan(): Promise<void> {\n    // Get current preferences and search\n    const preferences = this.preferencesInput.value\n      .split(',')\n      .map(pref => pref.trim())\n      .filter(pref => pref.length > 0);\n\n    const searchTerm = this.searchInput.value.trim() || null;\n\n    // Update UI\n    this.scanButton.style.display = 'none';\n    this.stopButton.style.display = 'block';\n    this.progressSection.classList.add('active');\n    this.updateStatus('Scanning items...');\n\n    // Start scan\n    await this.broadcastMessage({\n      type: 'START_SCAN',\n      payload: {\n        preferences,\n        searchTerm\n      } as StartScanPayload\n    });\n  }\n\n  private async stopScan(reason: 'user' | 'error' | 'complete'): Promise<void> {\n    // Update UI\n    this.scanButton.style.display = 'block';\n    this.stopButton.style.display = 'none';\n    this.progressSection.classList.remove('active');\n    this.updateStatus(reason === 'complete' ? 'Scan complete' : 'Scan stopped');\n\n    // Stop scan\n    await this.broadcastMessage({\n      type: 'STOP_SCAN',\n      payload: { reason } as StopScanPayload\n    });\n  }\n\n  private updateStatus(message: string): void {\n    this.statusElement.textContent = message;\n  }\n\n  private async broadcastMessage(message: Message): Promise<void> {\n    // Send message to background script\n    await browser.runtime.sendMessage(message);\n\n    // Get all Vinted tabs\n    const tabs = await browser.tabs.query({\n      url: [\n        '*://*.vinted.com/*',\n        '*://*.vinted.fr/*',\n        '*://*.vinted.de/*'\n      ]\n    });\n\n    // Send message to each tab\n    await Promise.all(\n      tabs.map(tab => {\n        if (tab.id) {\n          return browser.tabs.sendMessage(tab.id, message).catch(() => {\n            // Ignore errors from inactive tabs\n          });\n        }\n      })\n    );\n  }\n}\n\n// Initialize popup when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  new VintedLensPopup();\n});\n"],"names":["debounce","func","wait","timeout","args","clearTimeout","setTimeout","VintedLensPopup","constructor","this","preferencesInput","document","getElementById","searchInput","scanButton","stopButton","settingsButton","statusElement","progressSection","querySelector","progressBar","progressCount","progressPercent","currentItem","initialize","storage","browser","local","get","value","join","setupEventListeners","addEventListener","updatePreferences","updateSearch","async","disabled","style","display","classList","add","startScan","stopScan","remove","runtime","openOptionsPage","onMessage","addListener","message","type","handleProgress","payload","progress","percent","Math","round","current","total","width","textContent","updateStatus","preferences","split","map","pref","trim","filter","length","set","broadcastMessage","search","searchTerm","reason","sendMessage","tabs","query","url","Promise","all","tab","id","catch"],"sourceRoot":""}