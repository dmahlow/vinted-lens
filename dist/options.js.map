{"version":3,"file":"options.js","mappings":"mBAGA,MAAMA,EAMJ,WAAAC,GACEC,KAAKC,YAAcC,SAASC,eAAe,UAC3CH,KAAKI,wBAA0BF,SAASC,eAAe,sBACvDH,KAAKK,WAAaH,SAASC,eAAe,QAC1CH,KAAKM,cAAgBJ,SAASC,eAAe,UAE7CH,KAAKO,YACP,CAEQ,gBAAMA,GAEZ,MAAMC,QCXHC,iBACL,MAAMC,QAAeC,QAAQC,QAAQC,MAAMC,IAAI,C,yBAK/C,MAAO,CACLC,mBAAoBL,EAAM,aAA6B,GACvDM,OAAQN,EAAM,QAAwB,GAE1C,CDCwBO,GAGpBjB,KAAKC,YAAYiB,MAAQV,EAAMQ,QAAU,GACzChB,KAAKI,wBAAwBc,OAASV,EAAMO,oBAAsB,IAAII,KAAK,MAG3EnB,KAAKoB,qBACP,CAEQ,mBAAAA,GACNpB,KAAKK,WAAWgB,iBAAiB,SAAS,KACxCrB,KAAKsB,cAAc,IAIrBtB,KAAKC,YAAYoB,iBAAiB,YAAaE,IAC/B,UAAVA,EAAEC,KACJxB,KAAKsB,cACP,IAGFtB,KAAKI,wBAAwBiB,iBAAiB,YAAaE,IAC3C,UAAVA,EAAEC,KACJxB,KAAKsB,cACP,GAEJ,CAEQ,kBAAMA,GACZ,MAAMN,EAAShB,KAAKC,YAAYiB,MAAMO,OAChCC,EAAc1B,KAAKI,wBAAwBc,MAC9CS,MAAM,KACNC,KAAIC,GAAQA,EAAKJ,SACjBK,QAAOD,GAAQA,EAAKE,OAAS,IAEhC,IAEE,IAAK/B,KAAKgC,eAAehB,GACvB,MAAM,IAAIiB,MAAM,gCCtCjBxB,eAA+BiB,SAC9Bf,QAAQC,QAAQC,MAAMqB,IAAI,CAC9B,YAA2BR,EAAYX,mBACvC,OAAsBW,EAAYV,QAEtC,CDqCYmB,CAAgB,CACpBnB,SACAD,mBAAoBW,IAGtB1B,KAAKoC,WAAW,8BAA+B,UACjD,CAAE,MAAOC,GACPrC,KAAKoC,WACHC,aAAiBJ,MAAQI,EAAMC,QAAU,0BACzC,QAEJ,CACF,CAEQ,cAAAN,CAAehB,GAGrB,OAAOA,EAAOuB,WAAW,YAAcvB,EAAOe,QAAU,EAC1D,CAEQ,UAAAK,CAAWE,EAAiBE,GAClCxC,KAAKM,cAAcmC,YAAcH,EACjCtC,KAAKM,cAAcoC,UAAY,UAAUF,IAE5B,YAATA,GACFG,YAAW,KACT3C,KAAKM,cAAcoC,UAAY,SAC/B1C,KAAKM,cAAcmC,YAAc,EAAE,GAClC,IAEP,EAIFvC,SAASmB,iBAAiB,oBAAoB,KAC5C,IAAIvB,CAAmB,G","sources":["webpack://vinted-lens/./src/options/index.ts","webpack://vinted-lens/./src/utils/index.ts"],"sourcesContent":["import { StorageKeys, UserPreferences } from '../types';\nimport { getStoredPreferences, savePreferences } from '../utils';\n\nclass VintedLensOptions {\n  private apiKeyInput: HTMLInputElement;\n  private defaultPreferencesInput: HTMLInputElement;\n  private saveButton: HTMLButtonElement;\n  private statusElement: HTMLElement;\n\n  constructor() {\n    this.apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n    this.defaultPreferencesInput = document.getElementById('defaultPreferences') as HTMLInputElement;\n    this.saveButton = document.getElementById('save') as HTMLButtonElement;\n    this.statusElement = document.getElementById('status') as HTMLElement;\n\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load stored preferences\n    const prefs = await getStoredPreferences();\n\n    // Set initial values\n    this.apiKeyInput.value = prefs.apiKey || '';\n    this.defaultPreferencesInput.value = (prefs.defaultPreferences || []).join(', ');\n\n    // Setup event listeners\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    this.saveButton.addEventListener('click', () => {\n      this.saveSettings();\n    });\n\n    // Save on Enter key in inputs\n    this.apiKeyInput.addEventListener('keypress', (e) => {\n      if (e.key === 'Enter') {\n        this.saveSettings();\n      }\n    });\n\n    this.defaultPreferencesInput.addEventListener('keypress', (e) => {\n      if (e.key === 'Enter') {\n        this.saveSettings();\n      }\n    });\n  }\n\n  private async saveSettings(): Promise<void> {\n    const apiKey = this.apiKeyInput.value.trim();\n    const preferences = this.defaultPreferencesInput.value\n      .split(',')\n      .map(pref => pref.trim())\n      .filter(pref => pref.length > 0);\n\n    try {\n      // Validate API key format (basic check)\n      if (!this.validateApiKey(apiKey)) {\n        throw new Error('Invalid API key format');\n      }\n\n      // Save settings\n      await savePreferences({\n        apiKey,\n        defaultPreferences: preferences\n      });\n\n      this.showStatus('Settings saved successfully', 'success');\n    } catch (error) {\n      this.showStatus(\n        error instanceof Error ? error.message : 'Failed to save settings',\n        'error'\n      );\n    }\n  }\n\n  private validateApiKey(apiKey: string): boolean {\n    // Basic validation for Anthropic API key format\n    // Should start with 'sk-ant-' and be at least 32 chars\n    return apiKey.startsWith('sk-ant-') && apiKey.length >= 32;\n  }\n\n  private showStatus(message: string, type: 'success' | 'error'): void {\n    this.statusElement.textContent = message;\n    this.statusElement.className = `status ${type}`;\n\n    if (type === 'success') {\n      setTimeout(() => {\n        this.statusElement.className = 'status';\n        this.statusElement.textContent = '';\n      }, 3000);\n    }\n  }\n}\n\n// Initialize options page when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  new VintedLensOptions();\n});\n","import {\n  StorageKeys,\n  UserPreferences,\n  ToastOptions,\n  AnthropicResponse,\n  GridAnalysisResponse\n} from '../types';\n\n// Storage utilities\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const result = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey\n  ]);\n\n  return {\n    defaultPreferences: result[StorageKeys.Preferences] || [],\n    apiKey: result[StorageKeys.ApiKey] || ''\n  };\n}\n\nexport async function savePreferences(preferences: Partial<UserPreferences>): Promise<void> {\n  await browser.storage.local.set({\n    [StorageKeys.Preferences]: preferences.defaultPreferences,\n    [StorageKeys.ApiKey]: preferences.apiKey\n  });\n}\n\n// Image utilities\nexport async function imageToBase64(url: string): Promise<string> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n// UI utilities\nexport function showToast(options: ToastOptions): void {\n  const existingToast = document.querySelector('.vinted-lens-toast');\n  if (existingToast) {\n    existingToast.remove();\n  }\n\n  const toast = document.createElement('div');\n  toast.className = `vinted-lens-toast ${options.type || ''}`;\n  toast.textContent = options.message;\n  document.body.appendChild(toast);\n\n  // Force reflow to trigger animation\n  toast.offsetHeight;\n  toast.classList.add('show');\n\n  setTimeout(() => {\n    toast.classList.remove('show');\n    setTimeout(() => toast.remove(), 300);\n  }, options.duration || 3000);\n}\n\n// Anthropic API utilities\nexport async function callAnthropic(\n  apiKey: string,\n  base64Images: string[],\n  preferences: string[],\n  searchTerms: string | null\n): Promise<string> {\n  const prompt = `Analyze these product images from Vinted.com.\nUser preferences: ${preferences.join(', ')}\n${searchTerms ? `Search terms: ${searchTerms}` : ''}\n\nFor each product, determine if it matches the preferences${searchTerms ? ' and search terms' : ''}.\nRespond with a JSON array where each item has:\n{\n  \"id\": \"item-[index]\",\n  \"matches\": boolean,\n  \"confidence\": number (0-1),\n  \"matchedCriteria\": string[]\n}`;\n\n  const messages = [\n    {\n      role: 'user',\n      content: [\n        { type: 'text', text: prompt },\n        ...base64Images.map(image => ({\n          type: 'image',\n          source: {\n            type: 'base64',\n            media_type: 'image/jpeg',\n            data: image.split(',')[1]\n          }\n        }))\n      ]\n    }\n  ];\n\n  try {\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'anthropic-api-key': apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: 'claude-3-opus-20240229',\n        max_tokens: 1024,\n        messages\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => null);\n      throw new Error(\n        errorData?.error?.message ||\n        `Anthropic API error (${response.status}): ${response.statusText}`\n      );\n    }\n\n    const data = await response.json() as AnthropicResponse;\n\n    if (!data.content || !Array.isArray(data.content)) {\n      throw new Error('Invalid response format from Claude API');\n    }\n\n    // Get the last message content which contains our analysis\n    const lastMessage = data.content[data.content.length - 1];\n\n    if (!lastMessage.text) {\n      throw new Error('No text content in Claude response');\n    }\n\n    // Parse the response as our expected grid analysis format\n    let gridAnalysis: GridAnalysisResponse[];\n    try {\n      gridAnalysis = JSON.parse(lastMessage.text);\n      if (!Array.isArray(gridAnalysis) || !gridAnalysis.every(item =>\n        typeof item.id === 'string' &&\n        typeof item.matches === 'boolean' &&\n        typeof item.confidence === 'number' &&\n        Array.isArray(item.matchedCriteria)\n      )) {\n        throw new Error('Invalid grid analysis format');\n      }\n    } catch (parseError) {\n      throw new Error('Failed to parse Claude response as grid analysis');\n    }\n\n    return JSON.stringify(gridAnalysis);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    throw new Error('Failed to communicate with Claude API');\n  }\n}\n\n// Function utilities\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// DOM utilities\nexport function isElementInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n"],"names":["VintedLensOptions","constructor","this","apiKeyInput","document","getElementById","defaultPreferencesInput","saveButton","statusElement","initialize","prefs","async","result","browser","storage","local","get","defaultPreferences","apiKey","getStoredPreferences","value","join","setupEventListeners","addEventListener","saveSettings","e","key","trim","preferences","split","map","pref","filter","length","validateApiKey","Error","set","savePreferences","showStatus","error","message","startsWith","type","textContent","className","setTimeout"],"sourceRoot":""}