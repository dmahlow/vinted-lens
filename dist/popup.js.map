{"version":3,"file":"popup.js","mappings":"mBAiKO,SAASA,EACdC,EACAC,GAEA,IAAIC,EAEJ,MAAO,IAAIC,KACTC,aAAaF,GACbA,EAAUG,YAAW,IAAML,KAAQG,IAAOF,EAAK,CAEnD,CCnKA,MAAMK,EAMJ,WAAAC,GACEC,KAAKC,iBAAmBC,SAASC,eAAe,eAChDH,KAAKI,YAAcF,SAASC,eAAe,UAC3CH,KAAKK,eAAiBH,SAASC,eAAe,YAC9CH,KAAKM,cAAgBJ,SAASC,eAAe,UAE7CH,KAAKO,YACP,CAEQ,gBAAMA,GAEZ,MAAMC,QAAgBC,QAAQD,QAAQE,MAAMC,IAAI,C,gCAMhDX,KAAKC,iBAAiBW,OAASJ,EAAO,aAA6B,IAAIK,KAAK,MAC5Eb,KAAKI,YAAYQ,MAAQJ,EAAO,eAA+B,GAG/DR,KAAKc,qBACP,CAEQ,mBAAAA,GAENd,KAAKC,iBAAiBc,iBAAiB,QAASxB,GAAS,KACvDS,KAAKgB,mBAAmB,GACvB,MAGHhB,KAAKI,YAAYW,iBAAiB,QAASxB,GAAS,KAClDS,KAAKiB,cAAc,GAClB,MAGHjB,KAAKK,eAAeU,iBAAiB,SAAS,KAC5CN,QAAQS,QAAQC,iBAAiB,GAErC,CAEQ,uBAAMH,GACZ,MAAMI,EAAcpB,KAAKC,iBAAiBW,MACvCS,MAAM,KACNC,KAAIC,GAAQA,EAAKC,SACjBC,QAAOF,GAAQA,EAAKG,OAAS,UAE1BjB,QAAQD,QAAQE,MAAMiB,IAAI,CAC9B,YAA2BP,IAG7BpB,KAAK4B,aAAa,6BAGZ5B,KAAK6B,iBAAiB,CAC1BC,KAAM,qBACNC,QAAS,CAAEX,gBAEf,CAEQ,kBAAMH,GACZ,MAAMe,EAAShC,KAAKI,YAAYQ,MAAMY,aAEhCf,QAAQD,QAAQE,MAAMiB,IAAI,CAC9B,cAA6BK,IAG/BhC,KAAK4B,aAAa,wBAGZ5B,KAAK6B,iBAAiB,CAC1BC,KAAM,gBACNC,QAAS,CAAEC,WAEf,CAEQ,YAAAJ,CAAaK,GACnBjC,KAAKM,cAAc4B,YAAcD,EACjCpC,YAAW,KACTG,KAAKM,cAAc4B,YAAc,kBAAkB,GAClD,IACL,CAEQ,sBAAML,CAAiBI,SAEvBxB,QAAQS,QAAQiB,YAAYF,GAGlC,MAAMG,QAAa3B,QAAQ2B,KAAKC,MAAM,CACpCC,IAAK,CACH,qBACA,oBACA,6BAKEC,QAAQC,IACZJ,EAAKd,KAAImB,IACP,GAAIA,EAAIC,GACN,OAAOjC,QAAQ2B,KAAKD,YAAYM,EAAIC,GAAIT,GAASU,OAAM,QAGzD,IAGN,EAIFzC,SAASa,iBAAiB,oBAAoB,KAC5C,IAAIjB,CAAiB,G","sources":["webpack://vinted-lens/./src/utils/index.ts","webpack://vinted-lens/./src/popup/index.ts"],"sourcesContent":["import {\n  StorageKeys,\n  UserPreferences,\n  ToastOptions,\n  AnthropicResponse,\n  GridAnalysisResponse\n} from '../types';\n\n// Storage utilities\nexport async function getStoredPreferences(): Promise<UserPreferences> {\n  const result = await browser.storage.local.get([\n    StorageKeys.Preferences,\n    StorageKeys.ApiKey\n  ]);\n\n  return {\n    defaultPreferences: result[StorageKeys.Preferences] || [],\n    apiKey: result[StorageKeys.ApiKey] || ''\n  };\n}\n\nexport async function savePreferences(preferences: Partial<UserPreferences>): Promise<void> {\n  await browser.storage.local.set({\n    [StorageKeys.Preferences]: preferences.defaultPreferences,\n    [StorageKeys.ApiKey]: preferences.apiKey\n  });\n}\n\n// Image utilities\nexport async function imageToBase64(url: string): Promise<string> {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => resolve(reader.result as string);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n// UI utilities\nexport function showToast(options: ToastOptions): void {\n  const existingToast = document.querySelector('.vinted-lens-toast');\n  if (existingToast) {\n    existingToast.remove();\n  }\n\n  const toast = document.createElement('div');\n  toast.className = `vinted-lens-toast ${options.type || ''}`;\n  toast.textContent = options.message;\n  document.body.appendChild(toast);\n\n  // Force reflow to trigger animation\n  toast.offsetHeight;\n  toast.classList.add('show');\n\n  setTimeout(() => {\n    toast.classList.remove('show');\n    setTimeout(() => toast.remove(), 300);\n  }, options.duration || 3000);\n}\n\n// Anthropic API utilities\nexport async function callAnthropic(\n  apiKey: string,\n  base64Images: string[],\n  preferences: string[],\n  searchTerms: string | null\n): Promise<string> {\n  const prompt = `Analyze these product images from Vinted.com.\nUser preferences: ${preferences.join(', ')}\n${searchTerms ? `Search terms: ${searchTerms}` : ''}\n\nFor each product, determine if it matches the preferences${searchTerms ? ' and search terms' : ''}.\nRespond with a JSON array where each item has:\n{\n  \"id\": \"item-[index]\",\n  \"matches\": boolean,\n  \"confidence\": number (0-1),\n  \"matchedCriteria\": string[]\n}`;\n\n  const messages = [\n    {\n      role: 'user',\n      content: [\n        { type: 'text', text: prompt },\n        ...base64Images.map(image => ({\n          type: 'image',\n          source: {\n            type: 'base64',\n            media_type: 'image/jpeg',\n            data: image.split(',')[1]\n          }\n        }))\n      ]\n    }\n  ];\n\n  try {\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'anthropic-api-key': apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: 'claude-3-opus-20240229',\n        max_tokens: 1024,\n        messages\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => null);\n      throw new Error(\n        errorData?.error?.message ||\n        `Anthropic API error (${response.status}): ${response.statusText}`\n      );\n    }\n\n    const data = await response.json() as AnthropicResponse;\n\n    if (!data.content || !Array.isArray(data.content)) {\n      throw new Error('Invalid response format from Claude API');\n    }\n\n    // Get the last message content which contains our analysis\n    const lastMessage = data.content[data.content.length - 1];\n\n    if (!lastMessage.text) {\n      throw new Error('No text content in Claude response');\n    }\n\n    // Parse the response as our expected grid analysis format\n    let gridAnalysis: GridAnalysisResponse[];\n    try {\n      gridAnalysis = JSON.parse(lastMessage.text);\n      if (!Array.isArray(gridAnalysis) || !gridAnalysis.every(item =>\n        typeof item.id === 'string' &&\n        typeof item.matches === 'boolean' &&\n        typeof item.confidence === 'number' &&\n        Array.isArray(item.matchedCriteria)\n      )) {\n        throw new Error('Invalid grid analysis format');\n      }\n    } catch (parseError) {\n      throw new Error('Failed to parse Claude response as grid analysis');\n    }\n\n    return JSON.stringify(gridAnalysis);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    throw new Error('Failed to communicate with Claude API');\n  }\n}\n\n// Function utilities\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// DOM utilities\nexport function isElementInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n","import {\n  Message,\n  StorageKeys,\n  UpdatePreferencesPayload,\n  UpdateSearchPayload\n} from '../types';\nimport { getStoredPreferences, debounce } from '../utils';\n\nclass VintedLensPopup {\n  private preferencesInput: HTMLInputElement;\n  private searchInput: HTMLInputElement;\n  private settingsButton: HTMLButtonElement;\n  private statusElement: HTMLElement;\n\n  constructor() {\n    this.preferencesInput = document.getElementById('preferences') as HTMLInputElement;\n    this.searchInput = document.getElementById('search') as HTMLInputElement;\n    this.settingsButton = document.getElementById('settings') as HTMLButtonElement;\n    this.statusElement = document.getElementById('status') as HTMLElement;\n\n    this.initialize();\n  }\n\n  private async initialize(): Promise<void> {\n    // Load stored values\n    const storage = await browser.storage.local.get([\n      StorageKeys.Preferences,\n      StorageKeys.CurrentSearch\n    ]);\n\n    // Set initial values\n    this.preferencesInput.value = (storage[StorageKeys.Preferences] || []).join(', ');\n    this.searchInput.value = storage[StorageKeys.CurrentSearch] || '';\n\n    // Setup event listeners\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    // Handle preference changes\n    this.preferencesInput.addEventListener('input', debounce(() => {\n      this.updatePreferences();\n    }, 500));\n\n    // Handle search changes\n    this.searchInput.addEventListener('input', debounce(() => {\n      this.updateSearch();\n    }, 500));\n\n    // Handle settings button click\n    this.settingsButton.addEventListener('click', () => {\n      browser.runtime.openOptionsPage();\n    });\n  }\n\n  private async updatePreferences(): Promise<void> {\n    const preferences = this.preferencesInput.value\n      .split(',')\n      .map(pref => pref.trim())\n      .filter(pref => pref.length > 0);\n\n    await browser.storage.local.set({\n      [StorageKeys.Preferences]: preferences\n    });\n\n    this.updateStatus('Preferences updated');\n\n    // Notify content script\n    await this.broadcastMessage({\n      type: 'UPDATE_PREFERENCES',\n      payload: { preferences } as UpdatePreferencesPayload\n    });\n  }\n\n  private async updateSearch(): Promise<void> {\n    const search = this.searchInput.value.trim();\n\n    await browser.storage.local.set({\n      [StorageKeys.CurrentSearch]: search\n    });\n\n    this.updateStatus('Search updated');\n\n    // Notify content script\n    await this.broadcastMessage({\n      type: 'UPDATE_SEARCH',\n      payload: { search } as UpdateSearchPayload\n    });\n  }\n\n  private updateStatus(message: string): void {\n    this.statusElement.textContent = message;\n    setTimeout(() => {\n      this.statusElement.textContent = 'Ready to analyze';\n    }, 2000);\n  }\n\n  private async broadcastMessage(message: Message): Promise<void> {\n    // Send message to background script\n    await browser.runtime.sendMessage(message);\n\n    // Get all Vinted tabs\n    const tabs = await browser.tabs.query({\n      url: [\n        '*://*.vinted.com/*',\n        '*://*.vinted.fr/*',\n        '*://*.vinted.de/*'\n      ]\n    });\n\n    // Send message to each tab\n    await Promise.all(\n      tabs.map(tab => {\n        if (tab.id) {\n          return browser.tabs.sendMessage(tab.id, message).catch(() => {\n            // Ignore errors from inactive tabs\n          });\n        }\n      })\n    );\n  }\n}\n\n// Initialize popup when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  new VintedLensPopup();\n});\n"],"names":["debounce","func","wait","timeout","args","clearTimeout","setTimeout","VintedLensPopup","constructor","this","preferencesInput","document","getElementById","searchInput","settingsButton","statusElement","initialize","storage","browser","local","get","value","join","setupEventListeners","addEventListener","updatePreferences","updateSearch","runtime","openOptionsPage","preferences","split","map","pref","trim","filter","length","set","updateStatus","broadcastMessage","type","payload","search","message","textContent","sendMessage","tabs","query","url","Promise","all","tab","id","catch"],"sourceRoot":""}